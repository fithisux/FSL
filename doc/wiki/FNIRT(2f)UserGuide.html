<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>FNIRT/UserGuide</title>
<link rel="stylesheet" type="text/css" media="all" charset="utf-8" href="fsl/css/common.css">
<link rel="stylesheet" type="text/css" media="screen" charset="utf-8" href="fsl/css/screen.css">
<link rel="stylesheet" type="text/css" media="print" charset="utf-8" href="fsl/css/print.css">
<style type="text/css">
ul.pagetitle{
  display: inline;
  margin: 0;
  padding: 0;
  font-size: 1.5em;
}
li.pagetitle{
  display: inline;
  margin: 0;
}
td.noborder {
  border: 0;
}
</style>
</head>
<body>
<table>
<tr>
<td class="noborder">
<img src="logo.png">
</td>
<td class="noborder">
<ul class="pagetitle">
<li class="pagetitle"><a class="backlink">FNIRT/UserGuide</a>
</ul>
<br><br>
[<a href="FSL.html">FSL</a>]&nbsp;[<a href="TitleIndex.html">TitleIndex</a>]&nbsp;[<a href="WordIndex.html">WordIndex</a>]&nbsp;
</td>
</tr>
</table>
<hr>
<div id="page">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><span class="anchor" id="line-2"></span><p class="line867"><div class="FslToolContents">
<h1>Contents</h1>
<ol><li><a href="./FNIRT.html">Introduction</a></li><li>User Guide<div class="contentslist"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="#Principles">Principles</a><ol><li>
<a href="#Deformation_model">Deformation model</a></li><li>
<a href="#Cost-function">Cost-function</a></li><li>
<a href="#Optimisation">Optimisation</a></li><li>
<a href="#Sub-sampling">Sub-sampling</a></li><li>
<a href="#Regularisation">Regularisation</a></li><li>
<a href="#Intensity_modulation">Intensity modulation</a></li><li>
<a href="#Is_it_diffeomorphic_.28and_what_does_.22diffeomorphic.22_mean.29.3F">Is it diffeomorphic (and what does "diffeomorphic" mean)?</a></li></ol></li><li>
<a href="#Software_implementation">Software implementation</a><ol><li>
<a href="#Configuration_files">Configuration files</a></li><li>
<a href="#Running_.60fnirt.60_efficiently">Running `fnirt` efficiently</a></li></ol></li><li>
<a href="#Understanding_sub-sampling_levels">Understanding sub-sampling levels</a><ol><li>
<a href="#List_of_parameters">List of parameters</a></li><li>
<a href="#Selected_parameters_explained">Selected parameters explained</a><ol><li>
<a href="#A--aff">--aff</a></li><li>
<a href="#A--inwarp">--inwarp</a></li><li>
<a href="#A--refmask">--refmask</a></li><li>
<a href="#A--inmask">--inmask</a></li><li>
<a href="#A--cout">--cout</a></li><li>
<a href="#A--iout">--iout</a></li><li>
<a href="#A--fout">--fout</a></li><li>
<a href="#A--jout">--jout</a></li><li>
<a href="#A--intout">--intout</a></li><li>
<a href="#A--warpres">--warpres</a></li><li>
<a href="#A--splineorder">--splineorder</a></li><li>
<a href="#A--numprec">--numprec</a></li><li>
<a href="#A--imprefm.2C_--imprefval.2C_--impinm.2C_--impinval">--imprefm, --imprefval, --impinm, --impinval</a></li><li>
<a href="#A--ssqlambda">--ssqlambda</a></li><li>
<a href="#A--regmod">--regmod</a></li><li>
<a href="#A--refderiv">--refderiv</a></li><li>
<a href="#A--intmod">--intmod</a></li><li>
<a href="#A--intorder">--intorder</a></li><li>
<a href="#A--biasres">--biasres</a></li><li>
<a href="#A--biaslambda">--biaslambda</a></li><li>
<a href="#A--jacrange">--jacrange</a></li><li>
<a href="#A--subsamp">--subsamp</a></li></ol></li><li>
<a href="#Now_what.3F_--_applywarp.21">Now what? -- applywarp!</a></li><li>
<a href="#Example_uses">Example uses</a></li></ol></li><li>
<a href="#Tools_for_handling_warps">Tools for handling warps</a><ol><li>
<a href="#Introduction">Introduction</a></li><li>
<a href="#fnirtfileutils">fnirtfileutils</a><ol><li>
<a href="#List_of_parameters-1">List of parameters</a></li><li>
<a href="#List_of_parameters-2">List of parameters</a></li></ol></li><li>
<a href="#invwarp">invwarp</a><ol><li>
<a href="#List_of_parameters-3">List of parameters</a></li></ol></li><li>
<a href="#convertwarp">convertwarp</a><ol><li>
<a href="#List_of_parameters-4">List of parameters</a></li></ol></li></ol></li><li>
<a href="#Some_examples_of_composite_warps">Some examples of composite warps</a><ol><li>
<a href="#Introduction-1">Introduction</a></li><li>
<a href="#Transforming_a_functional_image_into_standard_space">Transforming a functional image into standard space</a></li><li>
<a href="#Transforming_an_image_.28.27.27e.g..27.27_a_mask.29_in_standard_space_into_functional_space">Transforming an image (''e.g.'' a mask) in standard space into functional space</a></li></ol></li></ol></div></div></li></ol></div> <span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><p class="line867">
<h1 id="Principles">Principles</h1>
<span class="anchor" id="line-5"></span><span class="anchor" id="line-6"></span><p class="line867">
<h2 id="Deformation_model">Deformation model</h2>
<span class="anchor" id="line-7"></span><p class="line874">An affine transformation is characterised by a coordinate transform defined as <span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/linear_transformation.png" title="basis functions" /> <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line862">where <strong>A</strong> is a 4x4 matrix that is uniquely defined by 12 values (3 translations, 3 rotations, 3 zooms and 3 shears). This is sufficient to model overall differences in position and size between different brains. However it is often not sufficient for modelling more "local" differences such as <em>e.g.</em> enlarged ventricles or sulci. One may then instead use a non-linear transformation given by <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/non_linear_transformation.png" title="basis functions" /> <span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><p class="line862">The crucial part here are the <em>di(x,y,z)</em>, the warp fields. These are three (one for each dimension) fields of displacements, each of which have the same size as the image one is warping towards. They are often represented as linear combinations of basis-functions, thereby reducing the number of parameters that needs to be determined. In the case of fnirt they are represented by quadratic or cubic B-splines. <span class="anchor" id="line-16"></span><span class="anchor" id="line-17"></span><p class="line867">
<h2 id="Cost-function">Cost-function</h2>
<span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><p class="line874">The only cost-function presently implemented in fnirt is the "sum-of-squared differences". I.e. it attempts to minimize the function <span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/simple_cost_function.png" title="basis functions" /> <span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><p class="line862">where f denotes the "reference image" (e.g. the MNI152-template) and g denotes the image we want to warp. This would potentially limit its (fnirt's) use to cases where the images f and g are very similar, as opposed to other cost-functions like e.g. correlation-ratio or mutual information which are less sensitive to differences in contrast. However, the sum-of-squared differences cost-function has important advantages when <a href="./FNIRT(2f)UserGuide.html#Optimisation">searching</a> for the parameters that minimize its value. In addition fnirt has the option of <a href="./FNIRT(2f)UserGuide.html#Intensity_modulation">modulating the intensity</a> of f, both globally and locally, that addresses the issue of differences in contrast. <span class="anchor" id="line-25"></span><span class="anchor" id="line-26"></span><p class="line867">
<h2 id="Optimisation">Optimisation</h2>
<span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span><p class="line862">Registration (linear or non-linear) is really a non-linear optimisation problem in that there is some function O that depends in a non-linear fashion on some set of parameters <strong>w</strong>, and we want to find the values of <strong>w</strong> that minimizes O. Methods for finding the parameters <strong>w</strong> come in various flavors; Some will require only the ability to calculate O(<strong>w</strong>) whereas other relies also on the first, and possibly second, derivatives with respect to <strong>w</strong>. Methods in the latter category can potentially have large advantages over the former in terms of executions speed, something that is especially important when there are a large number of unknown parameters. <span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span><p class="line862">The Gauss-Newton method falls into the second category and is an approximation to the Newton-Raphson method that is valid when the function O is a sum-of-squares. It provides an explicit formula for where to take the next step in the parameter space <strong>w</strong>. <span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/gauss_newton_step.png" title="basis functions" /> <span class="anchor" id="line-33"></span><span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line862">Where <strong>H</strong> and ∇O denotes the Hessian and the gradient of O respectively. This is an advantage of Gauss-Newton over many other methods that will only provide a direction in which to search for a local minima, and will potentially enable faster convergence. <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line862">Fnirt has been implemented using a Levenberg-Marquardt modification of the Gauss-Newton method and great effort has gone into an efficient calculation of <strong>H</strong>. <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line867">
<h2 id="Sub-sampling">Sub-sampling</h2>
<span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line862">One of the difficulties in non-linear registration is to avoid logal minima. To understand this think of a section of cortex with two sulci from two different subjects. Let us furthermore assume that due to different shape brains the two sulci are shifted along the surface of the cortex in one brain relative to the other. A reasonable "solution" to this problem would be to translate the two sulci until they match up. Another solution would be to simply flatten out the existing sulci, and create two new ones in the correct position. Because of the considerable freedom in the transformations with a non-linear registrations this is something that could actually happen. One way of forcing the warps towards being more "reasonable" in that sense is through <a href="./FNIRT(2f)UserGuide.html#Regularisation">regularisation</a>. Another is "sub-sampling" or "multi-resolution" registration. That means that one starts out by sub-sampling, i.e. degrading the resolution of the images, by some factor and then register the resulting low-resolution images together. This ensures that gross structures in the images are registered first. The warp-fields from this first registration are now used as intial values in a second registration, this time with less sub-sampling and so forth until finally one is using the full resolution of the images (i.e. no sub-sampling at all). <span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><p class="line867">
<h2 id="Regularisation">Regularisation</h2>
<span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line874">All non-linear registration is a compromise between minimising the cost-function, i.e. between making the images look as similar as possible, and making the warps/displacements "reasonable". This is based on a notion that some warps are more reasonable, or probable, than others. We typicall find a smoother warp more likely than one that is very sharp. In addition there is the notion of one-to-one and onto. With one-to-one we mean that there can only be one point in the original space mapping into any given point in the transformed space and by onto we mean that there cannot be any points in the transformed space to which there is no mapping. <span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><p class="line874">This compromise is formalised by some regularising function, typically with concepts borrowed from mechanics. Examples of regularising functions are "membrane energy" and "bending energy". These are functions of the warps themselves, the images doesn't enter into it, that have a high value for sharp warps and a small value for smooth warps. <span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><p class="line874">Hence the cost-function that we really minimise is <span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/cost_function_with_regularisation.png" title="basis functions" /> <span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><p class="line874">where ε is the regularisation function and λ is a "fudge factor" that determines the relative balance between how "similar" the images get and how "smooth" we want the warps. <span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><p class="line874">Below is an example of warping a subject (with some atrophy) to the MNI152 template with "medium" regularisation (λ=30 with the ssqlambda option set) and with "little" regularisation (λ=8 with the ssqlambda option set) <span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><div><table><tbody><tr>  <td><p class="line891"><img alt="flirted_subj2.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/flirted_subj2.jpg" title="flirted_subj2.jpg" /></td>
  <td><p class="line891"><img alt="smooth_warps.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/smooth_warps.jpg" title="smooth_warps.jpg" /></td>
  <td><p class="line891"><img alt="fnirted_subj2.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/fnirted_subj2.jpg" title="fnirted_subj2.jpg" /></td>
  <td><p class="line891"><img alt="template.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/template.jpg" title="template.jpg" /></td>
  <td><p class="line891"><img alt="fnirted_subj2_less_reg.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/fnirted_subj2_less_reg.jpg" title="fnirted_subj2_less_reg.jpg" /></td>
  <td><p class="line891"><img alt="sharp_warps.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/sharp_warps.jpg" title="sharp_warps.jpg" /></td>
</tr>
<tr>  <td><span class="anchor" id="line-60"></span><p class="line862">Linearly registered image</td>
  <td><p class="line862">Warps with medium regularisation</td>
  <td><p class="line862">Warped image with medium regularisation</td>
  <td><p class="line862">MNI152 T1</td>
  <td><p class="line862">Warped image with little regularisation</td>
  <td><p class="line862"> Warps with little regularisation </td>
</tr>
</tbody></table></div><span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><p class="line874">In the images abov it can be seen that with the larger value for λ (warp and image on the left) the warps are smoother and the warped image is, possibly, a little less similar to the template. With the smaller value for λ (warp and image on the right) the image is slightly more similar to the template, in particular the ventricles and the left Sylvian fissure, but at the expense of sharper warps. For this particular data set there are more than ten voxels (in the whole volume) where the one-to-one condition has been violated when using the lower value for λ, so clearly the larger value is more appropriate in this case. <span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><p class="line862">We refer to λ as a "fudge factor", and the reason for that is that we have no principled way of deriving an appropriate value for it. It will have to be determined empirically for each "category" of images. If one for example wants to register structural T1-weighted images with reasonable contrast and signal-to-noise one determines, once and for all, a suitable value for λ and uses that for subsequent studies. There are some examples of "appropriate" values in the "<a href="./FNIRT(2f)UserGuide.html#Example_uses">Example uses</a>" section. <span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><p class="line867">
<h2 id="Intensity_modulation">Intensity modulation</h2>
<span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span><p class="line862">The sum-of-squared differences cost function assumes that the images <em>f</em> and <em>g</em> are identical save for some differences in shape, and can get its knickers in a twist when that is not the case. An example of this is when one of the images is affected by a bias-field while the other is not. <span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><div><table><tbody><tr>  <td><p class="line891"><img alt="flirted_bias.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/flirted_bias.jpg" title="flirted_bias.jpg" /></td>
  <td><p class="line891"><img alt="template.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/template.jpg" title="template.jpg" /></td>
  <td><p class="line891"><img alt="gl_obj_bias.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/gl_obj_bias.jpg" title="gl_obj_bias.jpg" /></td>
</tr>
<tr>  <td><span class="anchor" id="line-71"></span><p class="line862">flirted image</td>
  <td><p class="line862">MNI152 T1</td>
  <td><p class="line862">fnirted image</td>
</tr>
</tbody></table></div><span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><p class="line874">We can see from the images above that for this subject the linear registration (flirt) did a good job. We can also see that there is a considerable intensity gradient (bias-field) in the anterior-posterior direction of the image. When looking at the fnirted image we see how it (fnirt) has "tried to correct" for this by shrinking the white matter in the posterior part of the brain, thereby reducing the intensity. Conversly it has shrunk the gray matter in the frontal parts, increasing the intensity there. <span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><p class="line874">In fnirt this can be addressed using the various intensity modulation options that are available. For the example above the "local linear" option would be suitable. It is implemented by altering the cost-function to <span class="anchor" id="line-76"></span><span class="anchor" id="line-77"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/cost_function_with_bias.png" title="basis functions" /> <span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><p class="line862">where <em>b</em> is now a bias-field that is explicitly modelled as part of the registration and where the parameters <strong>β</strong> are estimated along with <strong>w</strong> Applying this model to the example above we obtain <span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><div><table><tbody><tr>  <td><p class="line891"><img alt="flirted_bias.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/flirted_bias.jpg" title="flirted_bias.jpg" /></td>
  <td><p class="line891"><img alt="template.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/template.jpg" title="template.jpg" /></td>
  <td><p class="line891"><img alt="obj_bias.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/obj_bias.jpg" title="obj_bias.jpg" /></td>
  <td><p class="line891"><img alt="bias_field.jpg" class="attachment" height="150" src="attachments/FNIRT(2f)UserGuide/bias_field.jpg" title="bias_field.jpg" /></td>
</tr>
<tr>  <td><span class="anchor" id="line-83"></span><p class="line862">flirted image</td>
  <td><p class="line862">MNI152 T1</td>
  <td><p class="line862">fnirted image</td>
  <td><p class="line862">bias-field</td>
</tr>
</tbody></table></div><span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><p class="line874">where we can now see that when explicitly modelling the bias-field the "superfluous" warps have dissapeared. We can also see that even in this case, where the linear registration has done a very good job, there are potential gains from non-linear registration. <span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span><p class="line867">
<h2 id="Is_it_diffeomorphic_.28and_what_does_.22diffeomorphic.22_mean.29.3F">Is it diffeomorphic (and what does "diffeomorphic" mean)?</h2>
<span class="anchor" id="line-88"></span><span class="anchor" id="line-89"></span><p class="line862">A diffeomorphic mapping from a space <em>U</em> to a space <em>V</em> is one which has exactly one position in <em>V</em> for each position in <em>U</em>, which also means that it is invertible and that the Jacobian of the mapping is greater than zero at each location. This is clearly a desirable property, and one which people try to achieve in non-linear registration. In recent years it has become popular to use algorithms where diffeomorphism is guaranteed by construction. To understand this we need to look at how the warps are constructed from a series of iterations. In our (oldfashioned) case the displacement field is constructed as the sum of the updates calculated at each iteration. <span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><p class="line867"><img align="top" alt="sum of displacements" class="attachment" src="attachments/FNIRT(2f)UserGuide/sum_of_displacements.png" title="sum of displacements" /> <span class="anchor" id="line-92"></span><span class="anchor" id="line-93"></span><p class="line874">This means that even if each and every update is diffeomorphic in itself, the sum may not neccessarily be. There are algorithms that will instead construct the displacement field from the updates as <span class="anchor" id="line-94"></span><span class="anchor" id="line-95"></span><p class="line867"><img align="top" alt="combination of displacments" class="attachment" src="attachments/FNIRT(2f)UserGuide/combination_of_displacements.png" title="combination of displacments" /> <span class="anchor" id="line-96"></span><span class="anchor" id="line-97"></span><p class="line867"><em>i.e.</em> they are warping the warps rather than adding them. In this latter case one can guarantee that <strong>d</strong> is diffeomorphic as long as each of the <strong>d</strong><sub>i</sub> are diffeomorphic. This means that one can use heavy regularisation (big λ) when calculating each update, thereby ensuring diffeomorphism for each step, and then perform many updates (iterations) thereby still accomodating large displacements. <span class="anchor" id="line-98"></span><span class="anchor" id="line-99"></span><p class="line867"><tt class="backtick">fnirt</tt> is <strong>not</strong> diffeomorphic by construction, <em>i.e.</em> it sums the updates. Hence after each update (iteration) there is a risk that the field is no longer diffeomorphic. Therefore <tt class="backtick">fnirt</tt> uses a different "trick" which means that after each sub-sampling level it checks for non-diffeomorphic fields (by searching for &lt;=0 Jacobians) and if it finds any it will project the field onto the closest diffeomorphic field. <span class="anchor" id="line-100"></span><span class="anchor" id="line-101"></span><p class="line862">This is, perhaps, less elegant then ensuring diffeomorphism by construction, but also has its own advantages. A method that guarantees dieffeomorphism by construction guarantees <strong>only</strong> that. The Jacobians can in principle become infinitely close to zero which can, depending on the reason for the registration, be a problem. In contrast fnirt has the ability to project the warp onto any manifold consisting of mappings with Jacobians within a specified range. By for example setting <tt class="backtick"></tt>--jacrange=0.2,5<tt class="backtick"></tt> one specifies that one wants to find the "best" warps of all those for which there are no local contractions/expansions of volume greater than 5. <span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><p class="line867">
<h1 id="Software_implementation">Software implementation</h1>
<span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><p class="line862">Fnirt is a command line program that is run by typing <tt class="backtick">fnirt</tt> followed by some set of parameters. The minimum you need to type is <span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=target_image&nbsp;--in=input_image</tt> <span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><p class="line874">but it is not very likely it will do you any good. Fnirt has a large set of parameters that determine what is done, and how it is done. Without a knowledge of these parameters you will not get the best results that you can. These parameters are described below, but it should be said that there are many of them, and to complicate things further they are linked such that the value of one parameter will determine what is the optimal value to use for another parameter. Hence, the command line options for fnirt offers a lot of flexibility but are difficult to use unless one is an expert on non-linear registration. We therefore offer the option of using configuration files that hides the complexity of fnirt and we strongly encourage using these rather than specifying command line options oneself. <span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><p class="line867">
<h2 id="Configuration_files">Configuration files</h2>
<span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span><p class="line862">A configuration file is a text file containing some or all of the parameters that can be specified for <tt class="backtick">fnirt</tt>. The name of the file should be passed as argument to the <tt class="backtick">--config</tt> parameter. It should be an ascii-file with one row for each parameter, and where comments (ignored by <tt class="backtick">fnirt</tt>) are preceeded by a #. A very simple (and silly) config file named <tt class="backtick">my_silly_file.cnf</tt> could look like <span class="anchor" id="line-114"></span><span class="anchor" id="line-115"></span><p class="line867"><tt class="backtick">#&nbsp;I&nbsp;want&nbsp;to&nbsp;use&nbsp;membrane&nbsp;energy&nbsp;for&nbsp;regularisation</tt><br>
 <span class="anchor" id="line-116"></span><tt class="backtick">--regmod=membrane_energy</tt> <span class="anchor" id="line-117"></span><span class="anchor" id="line-118"></span><p class="line874">It becomes more useful when it specifes all or most parameters with values suited for ones particular application. <span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line862">When a parameter is specified both in the config-file and on the command line the value on the command line takes precedence. For example with the example above we could run <tt class="backtick">fnirt</tt> with <span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--in=my_brain&nbsp;--ref=MNI152_T1_2mm&nbsp;--config=my_silly_file&nbsp;--regmod=bending_energy</tt> <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span><p class="line862">and the <tt class="backtick">--regmod=bending_energy</tt> on the command line will take precedence over the specification in <tt class="backtick">my_silly_file.</tt> <span class="anchor" id="line-125"></span><span class="anchor" id="line-126"></span><p class="line862">When you specify <tt class="backtick">--config=my_file</tt>, 'i.e.' without explicit path or extension, <tt class="backtick">fnirt</tt> will search for <tt class="backtick">./my_file</tt>, <tt class="backtick">./my_file.cnf</tt>, <tt class="backtick">${FSLDIR}/etc/flirtsch/my_fil</tt>e and <tt class="backtick">${FSLDIR}/etc/flirtsch/my_file.cnf</tt> in that order and use the first one that is found. <span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><p class="line862">As part of the fnirt distribution we supply two predefined config files: <tt class="backtick">T1_2_MNI152_2mm.cnf</tt> and <tt class="backtick">FA_2_FMRIB58_1mm.cnf</tt>. These contain parameters that have been found to be useful for registering a good quality T1-weighted 3D acquisition to the MNI152 template and for registering a good quality FA image to the FMRIB58 template. Together with the override facility this is probably the starting (an quite possible finishing) point for most users. Let us say for example that you want to register a T1 scan to the MNI152 template, but that you want to push warp-resolution a little beyond that given in <tt class="backtick">T1_2_MNI152_2mm.cnf</tt> (10mm isotropic). You may then <em>e.g</em>. run <tt class="backtick">fnirt</tt> with <span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--in=my_brain&nbsp;--config=T1_2_MNI152_2mm&nbsp;--warpres=6,6,6</tt> <span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><p class="line862">As our experience with <tt class="backtick">fnirt</tt> increases and we start using it for more applications we will supply more configuration files. Meanwhile if you have an application for which neither of the predefined config files is appropriate you may want to read about the individual parameters below and write your own file. We would then recommend to start with one of the predefined files (that which seems more appropriate given your application) and gradually change it to suit your application. Alternatively if your application is of sufficient general interest you may contact us and we can together devise a file for that application. <span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><p class="line867">
<h2 id="Running_.60fnirt.60_efficiently">Running `fnirt` efficiently</h2>
<span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line862">This paragraph contains some general advice that is useful to ensure that <tt class="backtick">fnirt</tt> is run in an "optimal" manner. <tt class="backtick">fnirt</tt> is designed to be a "medium resolution" non-linear registration method. Hence it is intended to be used with a warp-resolution of ~10mm. If/when attempting to go much below that (i.e. below ~5mm) one starts to pay a high price both in terms of working memory and execution time. In general this is not a big problem since a 10mm warp-resolution is typically sufficient to register two brains. <span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line862">Another factor that greatly affects execution time and memory requirements is the resolution and the field-of-view (FOV) of the <tt class="backtick">--ref</tt> image respectively. Let us say one wants for example to register one T1-scan to another. Tpical scan parameters may then be <em>e.g.</em> a 208x256x192 matrix-size with a 1x1x1mm resolution. With that FOV (208x256x192mm) there are typically thick slabs of non-brain in all directions and it may be cropped extensively (using the <tt class="backtick">fslroi</tt> command) without loss of any brain. If one is <em>e.g.</em> able to crop it down to a 146x194x130 matrix (numbers taken from a specific example) one will have reduced both execution time and memory requirements by 60%. <span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><p class="line862">If one additionaly specifies a subsampling of 2 at the lowest level (e.g. <tt class="backtick">--subsamp=8,4,2,2</tt>) there is a further reduction of execution time by a factor of eight. This implies that the full resolution of the images is never used for estimation of the warps, but that makes very little difference when using a warp-resolution of 10mm. When/if using subsampling of 2 the subsampled voxels have a size of 2x2x2mm which means that each spline-function has a support of 5832 voxels which is typically more than sufficient. If one uses the full resolution the support is a staggering 54872 voxels which is unneccessarily large and "wastes" execution time. <span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span><p class="line862">It should also be realized that the level of subsampling that is used when estimating the warps does not affect the resolution of the final warp-field. It will still produce a field with the full resolution of the <tt class="backtick">--ref</tt> volume and the registered volume will have the full resolution of the <tt class="backtick">--ref</tt> volume. An example of a config file that uses this "trick" is <tt class="backtick">FA_2_FMRIB58_1mm.cnf</tt>, which is used to register an FA-volume to the FMRIB 1mm (overkill) FA template. <span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line862">Other parameters that has an effect on efficiency include <tt class="backtick">--splineorder</tt> and <tt class="backtick">--numprec</tt>. <span class="anchor" id="line-145"></span><span class="anchor" id="line-146"></span><p class="line867">
<h1 id="Understanding_sub-sampling_levels">Understanding sub-sampling levels</h1>
<span class="anchor" id="line-147"></span><span class="anchor" id="line-148"></span><p class="line862">It is important to understand the concept of different sub-sampling levels and how that affects how one can/need to specify the different paramaters of <tt class="backtick">fnirt</tt>. As described <a href="./FNIRT(2f)UserGuide.html#Sub-sampling">above</a> in the theory section an execution of fnirt is really several consecutive registrations with increasing use of high frequency information. An example of a subsampling scheme might be --subsamp=4,2,1,1 which specifies that four consecutive registrations should be performed, the first with the --ref volume sub-sampled by a factor 4, the second by a factor 2 and the two final registrations at full resolution. Given this there are some parameters that it makes sense to define "once and for all" and use for all four registration. An example of such a parameter is <tt class="backtick">--regmod</tt> which specifies what regularisation model to use ("membrane energy" or "bending energy"). <span class="anchor" id="line-149"></span><span class="anchor" id="line-150"></span><p class="line862">For other parameters it makes more sense to specify a separate value for each sub-sampling level. An example of such a parameter is <tt class="backtick">--lambda</tt> which could for subsampling scheme above be set to e.g. <tt class="backtick">--lambda=200,75,40,20</tt>. What this means is that we are using a larger relative weighting of the regularisation term, <em>i.e</em>. we are forcing the warps to be smoother, for the registrations performed at lower resolution (larger sub-sampling). Note also how, in this example, at the final resolution we perform two registrations with decreasing regularisation. <span class="anchor" id="line-151"></span><span class="anchor" id="line-152"></span><p class="line862">Hence the parameters for <tt class="backtick">fnirt</tt> are divided into those that are defined "once and for all" and those that can/should be defined once for each sub-sampling level. That means that there must be a complete correspondence between the parameters in the latter category. It is for example correct to specify <span class="anchor" id="line-153"></span><span class="anchor" id="line-154"></span><p class="line867"><tt class="backtick">fnirt&nbsp;...&nbsp;--subsamp=4,2,1,1&nbsp;--lambda=200,75,40,20&nbsp;...</tt> <span class="anchor" id="line-155"></span><span class="anchor" id="line-156"></span><p class="line862">but <strong>not</strong> correct to specify <span class="anchor" id="line-157"></span><span class="anchor" id="line-158"></span><p class="line867"><tt class="backtick">fnirt&nbsp;...&nbsp;--subsamp=4,2,1&nbsp;--lambda=200,75,40,20&nbsp;...</tt> <span class="anchor" id="line-159"></span><span class="anchor" id="line-160"></span><p class="line874">The exception to this is that it is correct to specify a single value for parameters that can/should be defined once for each level of sub-sampling. An example of that would be <span class="anchor" id="line-161"></span><span class="anchor" id="line-162"></span><p class="line867"><tt class="backtick">fnirt&nbsp;...&nbsp;--refmask=my_mask&nbsp;--subsamp=4,2,1,1&nbsp;--applyrefmask=1&nbsp;...</tt> <span class="anchor" id="line-163"></span><span class="anchor" id="line-164"></span><p class="line874">which is equivalent to <span class="anchor" id="line-165"></span><span class="anchor" id="line-166"></span><p class="line867"><tt class="backtick">fnirt&nbsp;...&nbsp;--refmask=my_mask&nbsp;--subsamp=4,2,1,1&nbsp;--applyrefmask=1,1,1,1&nbsp;...</tt> <span class="anchor" id="line-167"></span><span class="anchor" id="line-168"></span><p class="line874">and implies that masking should be performed at each of the four registrations. <span class="anchor" id="line-169"></span><span class="anchor" id="line-170"></span><p class="line867">
<h2 id="List_of_parameters">List of parameters</h2>
<span class="anchor" id="line-171"></span><span class="anchor" id="line-172"></span><ul><li>Parameters that specify input files <span class="anchor" id="line-173"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">--ref=filname</tt> <span class="anchor" id="line-174"></span><ul><li style="list-style-type:none">Name of a file that defines the target space. E.g. MNI152_T1_2mm.nii. <span class="anchor" id="line-175"></span></li></ul><p class="line891"><tt class="backtick">--in=filename</tt> <span class="anchor" id="line-176"></span><ul><li style="list-style-type:none">Name of file with images you want to register. E.g. my_brain.nii <span class="anchor" id="line-177"></span></li></ul><p class="line891"><tt class="backtick">--config=config_file</tt> <span class="anchor" id="line-178"></span><ul><li style="list-style-type:none">Name of text-file with parameter settings. If you read nothing else, read this. <span class="anchor" id="line-179"></span></li></ul><p class="line891"><tt class="backtick">--aff=mat_fname</tt> <span class="anchor" id="line-180"></span><ul><li style="list-style-type:none">Name of text-file with affine starting guess. Typically the output from flirt. <span class="anchor" id="line-181"></span></li></ul><p class="line891"><tt class="backtick">--inwarp=coef/field_fname</tt> <span class="anchor" id="line-182"></span><ul><li style="list-style-type:none">Name of coefficient/field file with non-linear starting guess. Typically the output from previous run of fnirt. <span class="anchor" id="line-183"></span></li></ul><p class="line891"><tt class="backtick">--intin=fname&nbsp;of&nbsp;file&nbsp;with&nbsp;global/local&nbsp;intensity&nbsp;mapping</tt> <span class="anchor" id="line-184"></span><ul><li style="list-style-type:none">Name of file describing the intensity mapping. Typically the output from a previous run of fnirt. <span class="anchor" id="line-185"></span></li></ul><p class="line891"><tt class="backtick">--refmask=filename</tt> <span class="anchor" id="line-186"></span><ul><li style="list-style-type:none">Name of file with binary mask that determines interesting FOV. E.g. MNI152_T1_2mm_brain_mask_dil.nii <span class="anchor" id="line-187"></span></li></ul><p class="line891"><tt class="backtick">--inmask=filename</tt> <span class="anchor" id="line-188"></span><ul><li style="list-style-type:none">Name of file with binary mask that determine interesting FOV. E.g. my_mask.nii <span class="anchor" id="line-189"></span></li></ul></li></ul></li><li>Parameters specifying names of output-files <span class="anchor" id="line-190"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">--cout=filename</tt> <span class="anchor" id="line-191"></span><ul><li style="list-style-type:none">Name of output-file containing the coefficients that determine the warp-field. <span class="anchor" id="line-192"></span></li></ul><p class="line891"><tt class="backtick">--iout=filename</tt> <span class="anchor" id="line-193"></span><ul><li style="list-style-type:none">Name of output-file containing the --in image after it has been warped to the --ref image. <span class="anchor" id="line-194"></span></li></ul><p class="line891"><tt class="backtick">--fout=filename</tt> <span class="anchor" id="line-195"></span><ul><li style="list-style-type:none">Name of output-file containing the warp-field itself. <span class="anchor" id="line-196"></span></li></ul><p class="line891"><tt class="backtick">--jout=filename</tt> <span class="anchor" id="line-197"></span><ul><li style="list-style-type:none">Name of output-file containing the Jacobian-field. Useful for diagnosis and VBM. <span class="anchor" id="line-198"></span></li></ul><p class="line891"><tt class="backtick">--refout=filename</tt> <span class="anchor" id="line-199"></span><ul><li style="list-style-type:none">Name of output-file containing the --ref image after intensity modulation. Useful for diagnosis. <span class="anchor" id="line-200"></span></li></ul><p class="line891"><tt class="backtick">--intout=filename</tt> <span class="anchor" id="line-201"></span><ul><li style="list-style-type:none">Name of output-file/files containing intensity modulation information. <span class="anchor" id="line-202"></span><span class="anchor" id="line-203"></span></li></ul></li></ul></li><li class="gap">Parameters that are are specified "once and for all" <span class="anchor" id="line-204"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">--warpres=xres,yres,zres</tt> <span class="anchor" id="line-205"></span><ul><li style="list-style-type:none">Resolution of warps (in mm). E.g. 10,10,10 <span class="anchor" id="line-206"></span></li></ul><p class="line891"><tt class="backtick">--splineorder=n</tt> <span class="anchor" id="line-207"></span><ul><li style="list-style-type:none">Order of B-spline (2/3). <span class="anchor" id="line-208"></span></li></ul><p class="line891"><tt class="backtick">--imprefm(=1/0)</tt> <span class="anchor" id="line-209"></span><ul><li style="list-style-type:none">If set =1 assumes that a certain value in --ref implies outside valid FOV. Set as default. <span class="anchor" id="line-210"></span></li></ul><p class="line891"><tt class="backtick">--impinm(=1/0)</tt> <span class="anchor" id="line-211"></span><ul><li style="list-style-type:none">If set =1 assumes that a certain value in --in implies outside valid FOV. Set as default. <span class="anchor" id="line-212"></span></li></ul><p class="line891"><tt class="backtick">--imprefval(=value)</tt> <span class="anchor" id="line-213"></span><ul><li style="list-style-type:none">If imprefm=1 imprefval specifies what value implies outside valid FOV. Default =0. <span class="anchor" id="line-214"></span></li></ul><p class="line891"><tt class="backtick">--impinval(=value)</tt> <span class="anchor" id="line-215"></span><ul><li style="list-style-type:none">If impinm=1 impinval specifies what value implies outside valid FOV. Default =0. <span class="anchor" id="line-216"></span></li></ul><p class="line891"><tt class="backtick">--ssqlambda=0/1</tt> <span class="anchor" id="line-217"></span><ul><li style="list-style-type:none">If set to 1, implies that λ should be multiplied by sum-of-squared differences. <span class="anchor" id="line-218"></span></li></ul><p class="line891"><tt class="backtick">--regmod=model</tt> <span class="anchor" id="line-219"></span><ul><li style="list-style-type:none">Specifies what regularisation-model should be used. E.g. bending_energy <span class="anchor" id="line-220"></span></li></ul><p class="line891"><tt class="backtick">--refderiv</tt> <span class="anchor" id="line-221"></span><ul><li style="list-style-type:none">If specified implies that derivatives should be calculated from --ref image. <span class="anchor" id="line-222"></span></li></ul><p class="line891"><tt class="backtick">--intmod=model</tt> <span class="anchor" id="line-223"></span><ul><li style="list-style-type:none">Specifies what intensity-normalisation model should be used. <span class="anchor" id="line-224"></span></li></ul><p class="line891"><tt class="backtick">--intorder=n</tt> <span class="anchor" id="line-225"></span><ul><li style="list-style-type:none">Specifies the order of polynomial intensity modulation. <span class="anchor" id="line-226"></span><span class="anchor" id="line-227"></span></li></ul></li></ul></li><li class="gap">Parameters that are specified once for each sub-sampling level <span class="anchor" id="line-228"></span><ul><li style="list-style-type:none"><p class="line891"><tt class="backtick">--subsamp=level1,level2,...</tt> <span class="anchor" id="line-229"></span><ul><li style="list-style-type:none">Levels of sub-sampling for which to perform registration. E.g. 4,2,1 <span class="anchor" id="line-230"></span></li></ul><p class="line891"><tt class="backtick">--miter=level1,level2,...</tt> <span class="anchor" id="line-231"></span><ul><li style="list-style-type:none">Number of iterations to run for each level. E.g. 5,5,10 <span class="anchor" id="line-232"></span></li></ul><p class="line891"><tt class="backtick">--reffwhm=level1,level2,...</tt> <span class="anchor" id="line-233"></span><ul><li style="list-style-type:none">Amount of smoothing to apply to --ref image for each level. E.g. 8,4,0 <span class="anchor" id="line-234"></span></li></ul><p class="line891"><tt class="backtick">--infwhm=level1,level2,...</tt> <span class="anchor" id="line-235"></span><ul><li style="list-style-type:none">Amount of smoothing to apply to --in image for each level. E.g. 10,6,2 <span class="anchor" id="line-236"></span></li></ul><p class="line891"><tt class="backtick">--lambda=level1,level2,...</tt> <span class="anchor" id="line-237"></span><ul><li style="list-style-type:none">Relative weight between sum-of-squared differences and regularisation for each level. E.g. 300,75,30 <span class="anchor" id="line-238"></span></li></ul><p class="line891"><tt class="backtick">--estint=level1,level2,...</tt> <span class="anchor" id="line-239"></span><ul><li style="list-style-type:none">Indicates if the parameters of the intensity model should be estimated or not (1/0). E.g. 1,1,0 <span class="anchor" id="line-240"></span></li></ul><p class="line891"><tt class="backtick">--applyrefmask=level1,level2,...</tt> <span class="anchor" id="line-241"></span><ul><li style="list-style-type:none">Indicates if masking in --ref-space should be performed (1/0). E.g. 0,0,1 <span class="anchor" id="line-242"></span></li></ul><p class="line891"><tt class="backtick">--applyinmask=level1,level2,...</tt> <span class="anchor" id="line-243"></span><ul><li style="list-style-type:none">Indicates if masking in --in-space should be performed (1/0). E.g. 0,0,1 <span class="anchor" id="line-244"></span><span class="anchor" id="line-245"></span></li></ul></li></ul></li></ul><p class="line867">
<h2 id="Selected_parameters_explained">Selected parameters explained</h2>
<span class="anchor" id="line-246"></span><span class="anchor" id="line-247"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-248"></span><span class="anchor" id="line-249"></span><p class="line867">
<h3 id="A--aff">--aff</h3>
<span class="anchor" id="line-250"></span><span class="anchor" id="line-251"></span><p class="line874">The value for this parameter is typically the name of a text-file obtained from flirt. A typical example would be <span class="anchor" id="line-252"></span><span class="anchor" id="line-253"></span><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;MNI152_T1_2mm.nii&nbsp;-in&nbsp;my_brain.nii&nbsp;-omat&nbsp;my_affine_guess.mat</tt><br>
 <span class="anchor" id="line-254"></span><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=my_brain.nii&nbsp;--aff=my_affine_guess.mat&nbsp;...</tt> <span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><p class="line862">Fnirt can be quite sensitive to the starting estimate ( the value of <tt class="backtick">--aff</tt>), and if flirt fails, or performs poorly, so will fnirt. It is therefore a good idea to make sure flirt does as well as it can. Flirt is e.g. typically more robust when data has been <a href="./BET.html">betted</a> first, whereas fnirt takes un-betted data. The following strategy will therefore often work well <span class="anchor" id="line-257"></span><span class="anchor" id="line-258"></span><p class="line867"><tt class="backtick">bet&nbsp;my_image.nii&nbsp;my_betted_image.nii</tt><br>
 <span class="anchor" id="line-259"></span><tt class="backtick">flirt&nbsp;-ref&nbsp;MNI152_T1_2mm_brain.nii&nbsp;-in&nbsp;my_betted_image.nii&nbsp;-omat&nbsp;my_affine_guess.mat</tt><br>
 <span class="anchor" id="line-260"></span><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=my_image.nii&nbsp;--aff=my_affine_guess.mat&nbsp;...</tt> <span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><span class="anchor" id="line-263"></span><span class="anchor" id="line-264"></span><p class="line867">
<h3 id="A--inwarp">--inwarp</h3>
<span class="anchor" id="line-265"></span><span class="anchor" id="line-266"></span><p class="line874">In the same way as -aff provides a "starting guess" for the affine part of the registration the --inwarp parmeter provides a "starting guess" for the non-linear part. The value for --inwarp can e.g. be a coefficient-file from a previous run of fnirt, or it can be a "field-file" generated by some other application. It can be useful e.g. when constructing a population specific template, where at each iteration one can expect that the field should be quite similar to in the previous iteration. By setting --inwarp parameter to the field from the previous iteration fnirt only has to estimate the incremental difference. <span class="anchor" id="line-267"></span><span class="anchor" id="line-268"></span><span class="anchor" id="line-269"></span><span class="anchor" id="line-270"></span><p class="line874">=== --intin ==== <span class="anchor" id="line-271"></span><span class="anchor" id="line-272"></span><p class="line874">When providing an initial guess for the non-linear warps (using the --inwarp parameter) it is a good idea to provide also an initial guess for the intensity mapping. The value of the parameter would then be the name/names of intensity mapping files produced by a previous run of fnirt. Depending on which model was used for intensity mapping in the previous run the information may be stored in an ASCII text-file and/or an image file with a bias-field. If specifying only the "basename", fnirt will find the relevant files itself. If fnirt was e.g. run with <span class="anchor" id="line-273"></span><span class="anchor" id="line-274"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=...&nbsp;...&nbsp;--intmod=global_non_linear_with_bias&nbsp;...&nbsp;--intout=my_intensity_mapping</tt> <span class="anchor" id="line-275"></span><span class="anchor" id="line-276"></span><p class="line862">in the previous run it will have produced two files: <tt class="backtick">my_intensity_mapping.txt</tt> containing the global mapping and <tt class="backtick">my_intensity_mapping.nii</tt> containing the bias-field. If then in the next run fnirt is passed the parameters <span class="anchor" id="line-277"></span><span class="anchor" id="line-278"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=...&nbsp;...&nbsp;--intin=my_intensity_mapping</tt> <span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span><p class="line862">both <tt class="backtick">my_intensity_mapping.txt</tt> and <tt class="backtick">my_intensity_mapping.nii</tt> will be read and used. <span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><p class="line867">
<h3 id="A--refmask">--refmask</h3>
<span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><p class="line862">Unlike <em>e.g.</em> flirt, fnirt is happiest to work on un-betted data. The reason for this is that even small local failures of <a href="./BET.html">bet</a> will create edges that fnirt will try to align. On the other hand we would like to focus our effort on the brain and are quite happy to ignore scalp and other extra cranial tissue. Including extra cranial tissue in the estimation may cause problems for 2 reasons. With a limited resolution of the warps we want to focus on aligning brain structures. Aligning for example the scalp may have a detrimental effect on the alignment of the cortex nearby. Secondly, the intensity in scalp and other extra cranial tissue tend to vary wildly between sequences, much more so than brain tissue. Therefore it may cause problems for the intensity mapping. <span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span><p class="line862">The solution is to use a (binary) mask in the space of the <tt class="backtick">--ref</tt> image. The cost-function, its gradient and Hessian is then calculated only for the voxels that fall within the mask. When registering to the MNI152 template it is often a good idea to use the mask supplied with that, <em>e.g.</em> as <span class="anchor" id="line-289"></span><span class="anchor" id="line-290"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=my_brain.nii&nbsp;--refmask=MNI152_T1_2mm_brain_mask_dil.nii&nbsp;...</tt>  <span class="anchor" id="line-291"></span><span class="anchor" id="line-292"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><p class="line867">
<h3 id="A--inmask">--inmask</h3>
<span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><p class="line862">Fnirt is rather primitive in its view of the brain. It considers it as a set of intensity values and has no model for different structures, tissue types etc. It would just as happily register a photo of your face to one of your house as two brains together. It is therefore unable to handle cases where a structure (<em>e.g.</em> a tumor or a stroke) is present in one of the images and not the other. However, it may still be of interest to register such a brain into a standard space in order to study effects on structures at some distance from the pathology. Note that this case is distinct from pathologies where existing structures changes its size and/or shape, a case that fnirt can often handle quite well (see <a href="./FNIRT.html">introduction</a>). <span class="anchor" id="line-297"></span><span class="anchor" id="line-298"></span><p class="line862">It can therefore be useful to supply a mask in the space of the <tt class="backtick">--in</tt> image. The mask must be binary and is inclusive (i.e. any voxel with a zero value gets excluded). The <tt class="backtick">--inmask</tt> is warped along with the <tt class="backtick">--in</tt> image in accordance with the current field. This means that the mask can/will cchange its size and shape as the <tt class="backtick">--in</tt> image is being warped. Voxels falling outside the mask will be excluded when estimating the warps. <span class="anchor" id="line-299"></span><span class="anchor" id="line-300"></span><p class="line862">An example may make it concrete. Let us say we have a tumor that has an intensity that deviates from the surrounding tissue, and let us say we did not mask it out. Fnirt would then shrink the tumor (and therefore the area with deviation intensities) as much as it can, meanwhile expanding surrounding tissues to "fill the <tt class="backtick">--ref</tt> brain out". If on the other hand we mask it out the intensity values within the tumor will be ignored and the tumor will be warped in accordance with the surrounding (non-masked) structures. <span class="anchor" id="line-301"></span><span class="anchor" id="line-302"></span><p class="line862">So, let us say you have a an image called <tt class="backtick">some_brain_with_tumor.nii</tt> that you want to register to the MNI152 template. You may then, e.g. in flsview, draw a ROI covering the tumour and save it as <tt class="backtick">tumor_mask.nii</tt>. You would then run fslmaths as <span class="anchor" id="line-303"></span><span class="anchor" id="line-304"></span><p class="line867"><tt class="backtick">fslmaths&nbsp;tumor_mask&nbsp;-sub&nbsp;1&nbsp;-mul&nbsp;-1&nbsp;tumor_mask</tt> <span class="anchor" id="line-305"></span><span class="anchor" id="line-306"></span><p class="line862">which changes the mask so that the tumor is now a "hole of zeros" in a binary image with ones. Finally you would run <tt class="backtick">fnirt</tt>, excluding the tumor from the calculations, using the command <span class="anchor" id="line-307"></span><span class="anchor" id="line-308"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=some_brain_with_tumor.nii&nbsp;--inmask=tumor_mask.nii&nbsp;...</tt>  <span class="anchor" id="line-309"></span><span class="anchor" id="line-310"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-311"></span>
<h3 id="A--cout">--cout</h3>
<span class="anchor" id="line-312"></span><span class="anchor" id="line-313"></span><p class="line862">This parameter specifies the name of the main output, a 4D nifti-file containing the spline coefficients and a copy of the affine transform passed as an argument to the <tt class="backtick">--aff</tt> parameter. Hence it has the full information about the transform and can be passed to e.g. <tt class="backtick">applywarp</tt> to warp an image or to <tt class="backtick">invwarp</tt> to create the inverse of the warp. Most of the <tt class="backtick">FSL</tt> software has been written such that one can pass either a coefficient-file or file containing the actual warp fields and they will be properly recognised and interpreted. This file is <strong>always</strong> created even if <tt class="backtick">--cout</tt> has not been specified. It will then be named after the <tt class="backtick">--in</tt> volume postfixed by "_warpcoef". <span class="anchor" id="line-314"></span><span class="anchor" id="line-315"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-316"></span><span class="anchor" id="line-317"></span><p class="line867">
<h3 id="A--iout">--iout</h3>
<span class="anchor" id="line-318"></span><span class="anchor" id="line-319"></span><p class="line862">This parameter specifies the name of a 3D nifti file containing the <tt class="backtick">--in</tt> image warped to the space of the <tt class="backtick">--ref</tt> image. If not specified this file will not be generated. It can always be created "later" using <tt class="backtick">applywarp</tt> and the output specified by <tt class="backtick">--cout</tt>. <span class="anchor" id="line-320"></span><span class="anchor" id="line-321"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-322"></span>
<h3 id="A--fout">--fout</h3>
<span class="anchor" id="line-323"></span><span class="anchor" id="line-324"></span><p class="line862">This parameter specifies the name of a 4D nifti file containing the actual warp-fields in the x-, y- and z-directions. If not specified this file will not be generated. It can always be created "later" using <tt class="backtick">fnirtfileutils</tt> and the output specified by <tt class="backtick">--cout</tt>. <span class="anchor" id="line-325"></span><span class="anchor" id="line-326"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-327"></span>
<h3 id="A--jout">--jout</h3>
<span class="anchor" id="line-328"></span><span class="anchor" id="line-329"></span><p class="line862">This parameter specifies the name of a 3D nifti file where each voxel contains the Jacobian determinant for that location. The Jacobian determinant is a relative measure that relates the volume in the original image to the volume in the warped image. If one <em>e.g.</em> observes a value 0.5 the interpretation is that that structure has been compressed by a factor of 2 from its original size in the <tt class="backtick">--in</tt> image when warped into the space of the <tt class="backtick">--ref</tt> image. This is useful when doing VBM where applying the Jacobian map to compensate for expansion/stretching is known as "Jacobian modulation". If not specified this file will not be generated. It can always be created "later" using <tt class="backtick">fnirtfileutils</tt> and the output specified by <tt class="backtick">--cout</tt>. <span class="anchor" id="line-330"></span><span class="anchor" id="line-331"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-332"></span>=== --refout ==== <span class="anchor" id="line-333"></span><span class="anchor" id="line-334"></span><p class="line862">Specifies the name of a copy of the <tt class="backtick">--ref&nbsp;image</tt> with intensity modulation applied. This is used mainly as a diagnostic tool for figuring out why/where a given registration went wrong. Not that it ever would. <span class="anchor" id="line-335"></span><span class="anchor" id="line-336"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-337"></span>
<h3 id="A--intout">--intout</h3>
<span class="anchor" id="line-338"></span><span class="anchor" id="line-339"></span><p class="line862">Specifies the base-name for file/files containing information about the intensity transform. Depending on what <tt class="backtick">--intmod</tt> has been set to This can be a text-file containing scaling/polynomial factors, a 3D nifti-file containing a multiplicative bias-field or a 4D nifti-file containing voxel-wise polynomial factors. This is useful mainly for "template building" where one would expect the intensity transform to be very similar from one iteration to the next. One can then generate these files using the <tt class="backtick">--intout</tt> parameter and then read them in as starting estimates for the next iteration using the <tt class="backtick">--intin</tt> parameter. <span class="anchor" id="line-340"></span><span class="anchor" id="line-341"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-342"></span>
<h3 id="A--warpres">--warpres</h3>
<span class="anchor" id="line-343"></span><span class="anchor" id="line-344"></span><p class="line862">Specifies the resolution (in mm) of the warps. In order to e.g. specify an isotropic resolution of 10mm one uses <tt class="backtick">--warpres=10,10,10</tt>. A warp resolution of <em>e.g</em>. 10mm does <strong>not</strong> imply that 10mm is the highest accuracy that can be obtained for registration of any given structure. It is rather related to how fast the displacements can change as on goes from one point to the next in the displacement field. An example of a situation where high resolution is useful is when registering an atrophied brain (with enlarged ventricles and an atrophied Putamen) to a "normal" template. One will then need to shrink (compress) the ventricle, and then right next to it one has to expand the Putamen. <span class="anchor" id="line-345"></span><span class="anchor" id="line-346"></span><p class="line862">To increase the resolution comes at no cost in terms of the risk for local minima/silly warps as long as a reasonable shedule of sub-sampling and values for λ is specified. It does however mean that <tt class="backtick">fnirt</tt> needs more memory to run and for standard desk/laptops the practical limit will be ~6-8mm. The warps are implemented as cubic B-splines with a knot-spacing that has to be an integer multiple of the voxel-size of the <tt class="backtick">--ref</tt> image. If a value is specified for <tt class="backtick">--warpres</tt> that is not and integer multiple the value will be adjusted down. So if the voxel-size of the <tt class="backtick">--ref</tt> image is 3x3x4mm and <tt class="backtick">--warpes</tt> is specified as <tt class="backtick">--warpres=10,10,10</tt> the actual resolution (knot-spacing) of the warps will be 9x9x8mm. <span class="anchor" id="line-347"></span><span class="anchor" id="line-348"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-349"></span>
<h3 id="A--splineorder">--splineorder</h3>
<span class="anchor" id="line-350"></span><span class="anchor" id="line-351"></span><p class="line862">Specifies the order of the B-spline functions modelling the warp-fields. A spline-function is a piecewise continuous polynomial-function and the order of the spline determines the order of the polynomial and the support of the spline. In <tt class="backtick">fnirt</tt> one can use splines of order 2 (quadratic) or 3 (the "well known" cubic B-spline). A spline of lower order (2 in this case) has a smaller support, <em>i.e</em>. it "covers" fewer voxels, for a given knot-spacing/warp-resolution. This means that the calculation of the hessian matrix <strong>H</strong> in the minimisation will be faster, and also that <strong>H</strong> will be sparser and thus use require less memory. That means that going to <tt class="backtick">--splineorder=2</tt> (compared to the default 3) will allow you to push the resolution of the warps a little further and/or save execution time and memory. <span class="anchor" id="line-352"></span><span class="anchor" id="line-353"></span><p class="line862">The downside with a 2nd order spline is that the resulting field will not have continuous 2nd derivatives which creates some difficulties when using bending energy for regularisation. However, the approximations we are using seem to work so it is not obvious if there really is an issue. We are using <tt class="backtick">--splineorder=3</tt> as default in <tt class="backtick">fnirt</tt> because we have more experience with using that. It is not inconcievable that that will change as we gain more experience. <span class="anchor" id="line-354"></span><span class="anchor" id="line-355"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-356"></span>
<h3 id="A--numprec">--numprec</h3>
<span class="anchor" id="line-357"></span><span class="anchor" id="line-358"></span><p class="line862">Its value can be either <tt class="backtick">float</tt> or <tt class="backtick">double</tt> (default) and it specifies the precision that the hessian <strong>H</strong> is calculated and stored in. Changing this to <tt class="backtick">float</tt> will decrease the amount of RAM needed to store <strong>H</strong> and will hence allow one to go to slightly higher warp-resolution. The default is <tt class="backtick">double</tt> since that is what we have used for most of the testing and validation. <span class="anchor" id="line-359"></span><span class="anchor" id="line-360"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-361"></span><span class="anchor" id="line-362"></span><p class="line867">
<h3 id="A--imprefm.2C_--imprefval.2C_--impinm.2C_--impinval">--imprefm, --imprefval, --impinm, --impinval</h3>
<span class="anchor" id="line-363"></span><span class="anchor" id="line-364"></span><p class="line862">When set to 1 the <tt class="backtick">--imprefm</tt> and <tt class="backtick">--impinm</tt> flags imply that a certain value implies that that voxel is outside the valid FOV and should be excluded when estimating the warps. This is useful for example if one has data that has already been resampled by an affine transform or if one uses skull stripped data. In both those cases there will be zeros in the image volume that does not mean that the intensity is actually zero, but rather that it is unknown. Note though that the recommended use of <tt class="backtick">fnirt</tt> is to not use skull-stripped data and to inform <tt class="backtick">fnirt</tt> of any affine warps through the <tt class="backtick">--aff</tt> parameter instead of resampling the data. The full form of this parameter is <span class="anchor" id="line-365"></span><span class="anchor" id="line-366"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=my_brain.nii&nbsp;--imprefm=1&nbsp;...</tt> <span class="anchor" id="line-367"></span><span class="anchor" id="line-368"></span><p class="line862">which specifies that a certain value implies that we are outside the valid FOV. Typically that value will be zero, in which case one does not need to bother with <tt class="backtick">--imprefval</tt>. Occasionally a software wil use some other value to indicate NaN (I have seen <em>e.g.</em> 1024) and then you can use <tt class="backtick">--imprefval</tt> to specify that <span class="anchor" id="line-369"></span><span class="anchor" id="line-370"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=my_brain.nii&nbsp;--imprefm=1&nbsp;--imprefval=1024&nbsp;...</tt> <span class="anchor" id="line-371"></span><span class="anchor" id="line-372"></span><p class="line862">Both <tt class="backtick">--imprefm</tt> and <tt class="backtick">--impinm</tt> are set to 1 as default. So if you know that all the zeros in your images are actuall zero and carry information you need to specify <tt class="backtick">imprefm=0</tt> and/or <tt class="backtick">impinm=0</tt>. <span class="anchor" id="line-373"></span><span class="anchor" id="line-374"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-375"></span>
<h3 id="A--ssqlambda">--ssqlambda</h3>
<span class="anchor" id="line-376"></span><span class="anchor" id="line-377"></span><p class="line862">The use of several sub-sampling steps (with different values of λ) helps prevent the registration from venturing into local minima. However, within a given sub-sampling step that regularisation is constant, and that could in turn cause the algorithm to take a "poor" initial step for that resolution level. By weighting λ by the current value for the sum-of-squared differences (between the <tt class="backtick">--ref</tt> image and the warped <tt class="backtick">--in</tt> image) the effective weight of the regularisation becomes higher for the initial iterations (when we are far from the solution and the sum-of-squares is large). That means that the initial step/steps are a little smoother than they would otherwise be, and hopefully that reduces the risk of finding a local minima. <span class="anchor" id="line-378"></span><span class="anchor" id="line-379"></span><p class="line867"><tt class="backtick">--ssqlambda</tt> is set to 1 as default, and it is typically a good idea to keep it like that. N.B. that the setting of --ssqlambda influences the recommended value/values for --lambda. The (average over all voxels) of the sum-of-squared differences is typically in the range 100-1000, and if --ssqlambda is set to 0 the value/values for --lambda should be adjusted up accordingly. <span class="anchor" id="line-380"></span><span class="anchor" id="line-381"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-382"></span>
<h3 id="A--regmod">--regmod</h3>
<span class="anchor" id="line-383"></span><span class="anchor" id="line-384"></span><p class="line862">The value of <tt class="backtick">--lambda</tt> determines the relative weight between the <a href="./FNIRT(2f)UserGuide.html#Regularisation">sum-of-squared differences and some function ε of the warps</a>. However, it is not clear what the exact form of that function (ε(<strong>w</strong>)) should be. We clearly desire "smoothness" in the warps so that points that are close together in the original space ends up (reasonably) close together in the warped space, but there are many potential options for how a particular local warp should be penalised by ε(<strong>w</strong>). In fnirt we have implemented two different choices for ε(w): Membrane Energy (<tt class="backtick">--regmod=membrane_energy</tt>) or Bending Energy (<tt class="backtick">--regmod=bending_energy</tt>). <span class="anchor" id="line-385"></span><span class="anchor" id="line-386"></span><p class="line874">The default is to use Bending Energy, and our testing indicate that that is slightly advantageous compared to Membrane Energy. <span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-389"></span>
<h3 id="A--refderiv">--refderiv</h3>
<span class="anchor" id="line-390"></span><span class="anchor" id="line-391"></span><p class="line874">When this parameter is set the (spatial) derivatives of the --in in image is approximated by those of the --ref image. Since the --ref images remains stationary that means that one does not need to recalculate the gradient and Hessian for each iteration, thereby saving execution time. However, this is only true for the simplest intensity models (none and global_linear) and is therefore of limited value for most cases. <span class="anchor" id="line-392"></span><span class="anchor" id="line-393"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-394"></span>
<h3 id="A--intmod">--intmod</h3>
<span class="anchor" id="line-395"></span><span class="anchor" id="line-396"></span><p class="line874">intmod is short for "intensity model" and is the parameter that allows fnirt to successfully use a sum-of-squared-differences cost-function even when the assumptions are not completely fulfilled for that. A "theoretical" explanation can be found here. The purpose is to model intensity differences between --ref and --in to avoid these from affecting the estimation of the warps. Modelling the intensity involves estimation of another set of parameters (in addition to those modelling the warps) and will hence increase both execution time and memory requirements. There are six different intensity models. These differ in the kind of differences they can model and also in the number of additional parameters that fnirt has to estimate. The models are <span class="anchor" id="line-397"></span><span class="anchor" id="line-398"></span><p class="line867"><tt class="backtick">--intmod=none</tt> <span class="anchor" id="line-399"></span><ul><li style="list-style-type:none">This is in fact no intensity model at all. It simply assumes that the images are identical apart from differences in shape. This is the model one "usually" means when talking about a "sum-of-squared differences cost-function". It is useful mainly for quantitative images such as e.g. FA-images. <span class="anchor" id="line-400"></span><span class="anchor" id="line-401"></span></li></ul><p class="line867"><tt class="backtick">--intmod=global_linear</tt> <span class="anchor" id="line-402"></span><ul><li style="list-style-type:none">This is the simplest of the actual intensity models. It assumes a linear relationship between the intensities in the two image. It needs to estimate one additional parameter, the slope of the linear relationship. It correponds (roughly) to a traditional correlation-coefficient cost-function. It is useful mainly for registering images acquired with the same scanner and sequence when the images has no or very little intensity inhomogeneity. <span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span></li></ul><p class="line867"><tt class="backtick">--intmod=global_non_linear</tt> <span class="anchor" id="line-405"></span><ul><li style="list-style-type:none">This model assumes that there is some curved relationship between the intensities in the two images. Imagine creating a scatter-plot where for each point takes its x-value from a voxel in the --ref image and the y-value from the same voxel in the (warped) --in image. Let us further assume that this scatter-plot displays a pattern where the majority of the points fall along a curved path. Using this model fnirt will fit a polynomial-function to that curve. The order of the polynomial will be determined by the value of the parameter --intorder (and this is also the number of additional parameters that needs to be estimated). It assumes that the curved intensity relationship is the same for all parts of the image (global). It corresponds (roughly) to a correlation-ratio cost-function. It is useful when both images (--ref and --in) have little or no intensity inhomogeneity and they have been acquired with similar sequences but on different scanners or with slightly different sequences on the same scanner. It could e.g. be used to register two T1-weighted images where the degree of weighting was a little different but would not work for registering a T1- to a T2-weighted image. <span class="anchor" id="line-406"></span><span class="anchor" id="line-407"></span></li></ul><p class="line867"><tt class="backtick">--intmod=local_linear</tt> <span class="anchor" id="line-408"></span><ul><li style="list-style-type:none"><p class="line862">Frequently MR images exhibit RF intensity inhomogeneity, i.e. there is a smoothly varying multiplicative bias-field. This option models such a field as a linear combination of B-splines (same as the warp fields). The properties of the field are determined by the parameters <tt class="backtick">--biasres</tt> and <tt class="backtick">--biaslambda</tt>. The number of additional parameters are also determined by --biasres and is typically substantial (several hundreds -- thousands). This option has no correspondence in traditional cost-functions. It is useful when images are acquired with the same scanner and sequence and there is a discernible bias-field <span class="anchor" id="line-409"></span><span class="anchor" id="line-410"></span></li></ul><p class="line867"><tt class="backtick">--intmod=global_non_linear_with_bias</tt> <span class="anchor" id="line-411"></span><ul><li style="list-style-type:none"><p class="line862">This model can be said to encompass both previous models (<tt class="backtick">global_non_linear</tt> and <tt class="backtick">local_linear</tt>). It models a global curvilinear relationship between the intensities (same as <tt class="backtick">global_non_linear</tt>) and modulates this locally with a multiplicative factor. The number of additional parameters are given by <tt class="backtick">--intorder</tt> and <tt class="backtick">--biasres</tt> and is the sum of the numbers for the two previous models. This means that execution time is roughly twice that of e.g. a global_linear model. It is useful when the images are acquired with different scanners and/or slightly different sequences and one or both images have discernible intensity inhomogeneities. This is a suitable model for many cases. One frequently wishes to register an individual image to a template representing some standard space. The subject/subjects constituting the template have typically been scanned elsewhere, and will therefore not have identical contrast. In addition it is very likely that the images will both (or at least ones own) be affected by bias-fields. This is e.g. the model that is used in the T1_2_MNI152_2mm.cnf configuration file. <span class="anchor" id="line-412"></span><span class="anchor" id="line-413"></span></li></ul><p class="line867"><tt class="backtick">--intmod=local_non_linear</tt> <span class="anchor" id="line-414"></span><ul><li style="list-style-type:none">The local_linear and global_non_linear_with_bias both estimate a single multiplicative bias-field. This model, in contrast, estimates several fields (the number of which is determined by --intorder). Let us assume --intorder=5. This means that for a given voxel we have five distinct values. These values are used as the coefficients for a local polynomial that models the intensities. This means that, unlike e.g. with a global_non_linear_with_bias model, it can model regionally varying contrast. This, we think, can be useful for high-field scanning where spatially varying flip-angles become a significant problem. However, this model has not been properly tested and its use would have to be considered experimental at this time. <span class="anchor" id="line-415"></span></li></ul><p class="line874">See also --estint for an explanation of how it can be useful to allow the intensity modelling to interact with the different subsampling steps. <span class="anchor" id="line-416"></span><span class="anchor" id="line-417"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-418"></span>
<h3 id="A--intorder">--intorder</h3>
<span class="anchor" id="line-419"></span><span class="anchor" id="line-420"></span><p class="line862">Determines the order of a polynomial that models a curvilinear relationship between the intensities in the two image. It is relevant for the <tt class="backtick">global_non_linear</tt>, the <tt class="backtick">global_non_linear_with_bias</tt> and the <tt class="backtick">local_non_linear</tt> models. An order of five (default) should be sufficient for most applications. <span class="anchor" id="line-421"></span><span class="anchor" id="line-422"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-423"></span>
<h3 id="A--biasres">--biasres</h3>
<span class="anchor" id="line-424"></span><span class="anchor" id="line-425"></span><p class="line862">Determines the knot-spacing for the splines that are used to model a bias-field. It means the same thing as <tt class="backtick">--warpres</tt>, but for the bias-field rather than the warp-fields. It is relevant for the <tt class="backtick">local_linear</tt>, the <tt class="backtick">global_non_linear_with_bias</tt> and the <tt class="backtick">local_non_linear</tt> models. Typically a bias-field varies quite slowly over space so a deafult of <tt class="backtick">--biasres=50,50,50</tt> has been choosen. <span class="anchor" id="line-426"></span><span class="anchor" id="line-427"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-428"></span>
<h3 id="A--biaslambda">--biaslambda</h3>
<span class="anchor" id="line-429"></span><span class="anchor" id="line-430"></span><p class="line862">Determines the relative weight of the sum-of-squared differences and the bending energy of the bias-field. This is similar to the <tt class="backtick">--lambda</tt> paramter, but for the bias-field rather than the warp-fields. Default is 10000. <span class="anchor" id="line-431"></span><span class="anchor" id="line-432"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-433"></span>
<h3 id="A--jacrange">--jacrange</h3>
<span class="anchor" id="line-434"></span><span class="anchor" id="line-435"></span><p class="line862">Specifies the allowable range of Jacobian determinants for the warps (see [#Is it diffeomorphic (and what does "diffeomorphic" mean)?this] for an explanation). The default is <tt class="backtick">--jacrange=0.01,100</tt>, which is (more or less) equivalent to ensuring diffeomorphism. By setting it to <tt class="backtick">--jacrange=-1</tt> one allows it to take any values (and to become non-diffeomorphic). For VBM purposes (where the Jacobians are used to modulate the tissue probabilities) it can be advantageous to set a more narrow range (e.g. <tt class="backtick">--jacrange=0.2,5</tt>) otherwise the presence of very small/large values may lead to highly non-normal (heavy tailed) distributions. <span class="anchor" id="line-436"></span><span class="anchor" id="line-437"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-438"></span>
<h3 id="A--subsamp">--subsamp</h3>
<span class="anchor" id="line-439"></span><span class="anchor" id="line-440"></span><p class="line862">As described above a multi-resolution approach consisting of sub-sampling, estimating the warps at currents scale, sample up, estimating the warps at the next scale etc is a way of avoiding local minima. The scheme for this multi resolution approach is given by the <tt class="backtick">--subsamp</tt> parameter. So for example <span class="anchor" id="line-441"></span><span class="anchor" id="line-442"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=my_brain.nii&nbsp;--subsamp=4,2,1</tt> <span class="anchor" id="line-443"></span><span class="anchor" id="line-444"></span><p class="line862">means that data will be subsampled by a factor of 4 and the transform will be calculated at that level. It will the be subsampled by a factor of 2 (i.e. an upsampling compared to the previous step) and the warps will be estimated at that scale, with the warps from the first scale as a starting estimate. And finally this will be repeated at the full resolution (<em>i.e.</em> subsampling 1). <span class="anchor" id="line-445"></span><span class="anchor" id="line-446"></span><p class="line874">The value of the --subsampl parameter will determine the "number of registrations" that are performed as steps in the "total" registration. There are a number of other parameters that can the be set on a "sub-registration" or on a "total registration" basis. So for example <span class="anchor" id="line-447"></span><span class="anchor" id="line-448"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8,4,0 <span class="anchor" id="line-449"></span>Means that you order three "sub-registrations" with sub-samplings 4, 2 and 1 respectively and that for the first registration you want the MNI152 template smoothed with an 8mm FWHM Gaussian filter, for the second with a 4mm filter and for the final step no smoothing at all. On the other hand <span class="anchor" id="line-450"></span><span class="anchor" id="line-451"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8 <span class="anchor" id="line-452"></span>means that you want the MNI152 smoothed by 8mm for all registration steps. These other parameters must either be specified once, and will then be applied to all sub-registrations, or as many times as there are sub-registraions. The parameters for which this is true are <span class="anchor" id="line-453"></span><span class="anchor" id="line-454"></span><p class="line874">--miter <span class="anchor" id="line-455"></span>--reffwhm <span class="anchor" id="line-456"></span>--infwhm <span class="anchor" id="line-457"></span>--lambda <span class="anchor" id="line-458"></span>--estint <span class="anchor" id="line-459"></span>The sub-sampling steps have to be monotonously decreasing, but do not have to be unique. One may for example want to run all steps at the full resolution, but with decreasing amount of regularistaion, as an optional strategy for avoiding local minima. That can be done e.g. with a command like <span class="anchor" id="line-460"></span><span class="anchor" id="line-461"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=1,1,1 --lambda=100,50,25 <span class="anchor" id="line-462"></span><span class="anchor" id="line-463"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-464"></span>--miter <span class="anchor" id="line-465"></span><span class="anchor" id="line-466"></span><p class="line874">Specifies the number of iterations that should be performed for each sub-registration. At present there is no proper convergence criterion implement in fnirt. Instead a fixed number of iterations is used for each step. Each iteration of a Gauss-Newton/Levenberg-Marquardt framework uses a lot of information compared to other optimisation methods such as e.g. steepest descent. That means that converengence is typically very rapid, especially at the cruder sub-sampling steps. Also, it is not critical to run to full convergence at the higher levels since these just serve as starting estimates for the lower levels. Our experience is that after a scheme like <span class="anchor" id="line-467"></span><span class="anchor" id="line-468"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --miter=5,5,10 <span class="anchor" id="line-469"></span>very little happens to the cost-function. Until a proper test for convergence has been implemented/tested this is something that will have to be determined heuristically. <span class="anchor" id="line-470"></span><span class="anchor" id="line-471"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-472"></span>--reffwhm, --infwhm <span class="anchor" id="line-473"></span><span class="anchor" id="line-474"></span><p class="line874">Specifies the amount of smoothing that should be applied to the --ref and the --in images respectively. It is typically a good idea to match this to the amount of sub-sampling you are using. An example would be the command <span class="anchor" id="line-475"></span><span class="anchor" id="line-476"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8,4,0 <span class="anchor" id="line-477"></span>which smoothes the --ref image with an 8mm FWHM Gaussian filter prior to subsampling with a factor of 4 for the first level of sub-registration. For the second level it smoothes it by 4mm prior to subsampling by a factor of 2. For the final level it applies no smoothing at all. <span class="anchor" id="line-478"></span><span class="anchor" id="line-479"></span><p class="line874">Since the MNI152 template is "a little smooth already" owing to its origin as an average of many subjects it is typically a good idea to smooth the --in image a little more that the --ref image. An example would be <span class="anchor" id="line-480"></span><span class="anchor" id="line-481"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8,4,0 --infwhm=10,6,2 <span class="anchor" id="line-482"></span>If you do not specify a value for the --reffwhm parameter it will be set to the same value as --infwhm. If you do not specify a value for --infwhm it will be set to 12,8. <span class="anchor" id="line-483"></span><span class="anchor" id="line-484"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-485"></span>--lambda <span class="anchor" id="line-486"></span><span class="anchor" id="line-487"></span><p class="line874">λ specifies the relative weighting of the sum-of-squared differences and the regularisation (smoothness) of the warps. A larger value of λ implies a smoother warp-field, at the expense of how similar to the --ref image that the --in image will end up being. There is no principled way to determine the "correct" value and suitable values for λ will have to be determined for each "type of data". It will e.g. be the case that a different set of parameters will be used when warping good quality T1-weighted structural images to the MNI152 template compared to when matching (relatively noisy) FA images to the FMRIB58 template. It may also be that if your T1-weighted scans have relatively poor SNR, poor contrast and/or highly non-isotropic voxels you may have to use a different set of λ values when matching to the MNI152 template compared to if you have optimal quality data. <span class="anchor" id="line-488"></span><span class="anchor" id="line-489"></span><p class="line874">You can either specify a single λ for all levels of subsampling (--subsamp) or one for each level like <span class="anchor" id="line-490"></span><span class="anchor" id="line-491"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --lambda=300,75,30 ... <span class="anchor" id="line-492"></span>This is usually a good idea and has the advantage of providing over-fitting at the early stage of the registration where the gross features are aligned, while allowing a closer registration at the later stages. This same strategy can be employed even if not utilising the multi-resolution approach by specifying <span class="anchor" id="line-493"></span><span class="anchor" id="line-494"></span><p class="line874">fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=1,1,1 --lambda=300,75,30 ... <span class="anchor" id="line-495"></span>which also prevents over-fitting at the earlier stages. The difference is mainly one of computational efficiency. <span class="anchor" id="line-496"></span><span class="anchor" id="line-497"></span><p class="line874">The specification of λ is (sadly) complicated a little by its interaction with the parameters --ssqlambda and --regmod. Therefore a set of values for λ is only "valid" for a specific combination of values for those two parameters. Unless you are a power user who wants to find a set of parameters for a special type of data it is probably easiest to use a pre-determined set from the examples or using a predefined config file. <span class="anchor" id="line-498"></span><span class="anchor" id="line-499"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-500"></span>--estint <span class="anchor" id="line-501"></span><span class="anchor" id="line-502"></span><p class="line874">This parameter determines if the parameters of the chosen intesity-model should be estimated or not. This may be useful, and may save time, in conjunction with subsampling schemes. For example in the T1_2_MNI152_2mm.cnf configuration file it is used like <span class="anchor" id="line-503"></span><span class="anchor" id="line-504"></span><p class="line874">fnirt ... --subsamp=4,4,2,2,1,1 --lambda=300,150,100,50,40,30 --miter=5,5,5,5,5,10 --estint=1,1,1,1,1,0 <span class="anchor" id="line-505"></span>Here it is assumed that when we get to the final 10 iterations (at the full resolution) the parameters of the intensity model have already been determined with sufficient precision. By therefore leaving them out of those iterations (instead using the parameters that have already been determined) one saves almost 50% of the execution time. <span class="anchor" id="line-506"></span><span class="anchor" id="line-507"></span><p class="line867"><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-508"></span><span class="anchor" id="line-509"></span><p class="line874">--applyrefmask, --applyinmask <span class="anchor" id="line-510"></span><span class="anchor" id="line-511"></span><p class="line874">This parameter indicates if the masks specfied with the --refmask and --inmask parameters should be used or not. You might think "dooh, why else would I have specified them?". The reason is that it is sometimes an advantage to not use the mask for the early iterations. An example could be e.g. <span class="anchor" id="line-512"></span><span class="anchor" id="line-513"></span><p class="line874">fnirt ... --ref=MNI152_T1_2mm.nii.gz --refmask=MNI152_T1_2mm_brain_mask_dil.nii.gz --subsamp=4,4,2,2,1,1 --applyrefmask=0,0,0,0,1,1 ... <span class="anchor" id="line-514"></span>where we are not using the brain-mask for the initial (lower resolution) registration steps. This is because the extracranial tissues may give information the improves the robustness of the initial steps. Once one goes to the full resolution one is hopefully quite close to the "true" solution, and then one wants to use the mask to ensure that the registration of the cortical surface is not affected by the scalp. This "trick" can be used when observing that a registration has gone wrong (doesn't look quite right). Sometimes it will work.  <span class="anchor" id="line-515"></span><a href="./FNIRT(2f)UserGuide.html#List_of_parameters">Back to list of parameters</a> <span class="anchor" id="line-516"></span><span class="anchor" id="line-517"></span><p class="line867">
<h2 id="Now_what.3F_--_applywarp.21">Now what? -- applywarp!</h2>
<span class="anchor" id="line-518"></span><span class="anchor" id="line-519"></span><p class="line874">So you have fnirted your images. So you have admired how well they match the template. Now what will you do? <span class="anchor" id="line-520"></span><span class="anchor" id="line-521"></span><p class="line862">You can try using <tt class="backtick">applywarp</tt> to apply the warps (aptly named, huh?) to some other images. Let us e.g. say that you have some functional data <tt class="backtick">func.nii</tt> and some structrural data <tt class="backtick">struct.nii</tt> for the same subject. What you ultimately want is to have your structural data in the MNI152 space, but you realise that there is probably too little structure in the functional scan to drive a non-linear registration. You can then use the following strategy. Start by registering your functional data to the structural scan doing <em>e.g</em>. <span class="anchor" id="line-522"></span><span class="anchor" id="line-523"></span><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;struct.nii&nbsp;-in&nbsp;func.nii&nbsp;-omat&nbsp;func2struct.mat&nbsp;-dof&nbsp;6</tt> <span class="anchor" id="line-524"></span><span class="anchor" id="line-525"></span><p class="line874">Where the text-file func2struct.mat now contains the rigid body transform that maps func.nii onto struct.nii. The next step is to get an intial affine transform mapping struct.nii onto the MNI152 template. <span class="anchor" id="line-526"></span><span class="anchor" id="line-527"></span><p class="line867"><tt class="backtick">bet&nbsp;struct.nii&nbsp;betted_struct.nii</tt> <span class="anchor" id="line-528"></span><tt class="backtick">flirt&nbsp;-ref&nbsp;MNI152_T1_2mm_brain.nii&nbsp;-in&nbsp;betted_struct.nii&nbsp;-omat&nbsp;aff_struct2mni.mat</tt> <span class="anchor" id="line-529"></span><span class="anchor" id="line-530"></span><p class="line874">Then we use that as initial guess for fnirt <span class="anchor" id="line-531"></span><span class="anchor" id="line-532"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=struct.nii&nbsp;--aff=aff_struct2mni.mat&nbsp;...&nbsp;--cout=warp_struct2mni.nii</tt> <span class="anchor" id="line-533"></span><span class="anchor" id="line-534"></span><p class="line874">And then we use that to resample the functional scan into the MNI152 space. <span class="anchor" id="line-535"></span><span class="anchor" id="line-536"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=MNI152_T1_2mm.nii&nbsp;--in=func.nii&nbsp;--out=funcInMNI.nii&nbsp;--coef=warp_struct2mni.nii&nbsp;--premat=func2struct.mat</tt> <span class="anchor" id="line-537"></span><span class="anchor" id="line-538"></span><p class="line862">We are now feeding applywarp information both about the struct-&gt;MNI152 mapping and about the func-&gt;struct mapping allowing it to map from func to MNI152 in a single step. More information on how to use applywarp can be found here <span class="anchor" id="line-539"></span><span class="anchor" id="line-540"></span><p class="line867">
<h2 id="Example_uses">Example uses</h2>
<span class="anchor" id="line-541"></span><span class="anchor" id="line-542"></span><p class="line874">For the following set of "standard tasks" the commands below are likely to work for you, provided that your data are of reasonable quality. <span class="anchor" id="line-543"></span><span class="anchor" id="line-544"></span><p class="line874">Registering T1-structural to MNI152 <span class="anchor" id="line-545"></span><span class="anchor" id="line-546"></span><p class="line867"><tt class="backtick">bet&nbsp;my_structural&nbsp;my_betted_structural</tt><br>
 <span class="anchor" id="line-547"></span><tt class="backtick">flirt&nbsp;-ref&nbsp;${FSLDIR}/data/standard/MNI152_T1_2mm_brain&nbsp;-in&nbsp;my_betted_structural&nbsp;-omat&nbsp;my_affine_transf.mat</tt><br>
 <span class="anchor" id="line-548"></span><tt class="backtick">fnirt&nbsp;--in=my_structural&nbsp;--aff=my_affine_transf.mat&nbsp;--cout=my_nonlinear_transf&nbsp;--config=T1_2_MNI152_2mm</tt><br>
 <span class="anchor" id="line-549"></span><tt class="backtick">applywarp&nbsp;--ref=${FSLDIR}/data/standard/MNI152_T1_2mm&nbsp;--in=my_structural&nbsp;--warp=my_nonlinear_transf&nbsp;--out=my_warped_structural</tt> <span class="anchor" id="line-550"></span><span class="anchor" id="line-551"></span><p class="line874">Registering functional data (or any non-T1 image data) to MNI152 (via structural scan) <span class="anchor" id="line-552"></span><span class="anchor" id="line-553"></span><p class="line867"><tt class="backtick">bet&nbsp;my_structural&nbsp;my_betted_structural</tt><br>
 <span class="anchor" id="line-554"></span><tt class="backtick">flirt&nbsp;-ref&nbsp;my_betted_structural&nbsp;-in&nbsp;my_functional&nbsp;-dof&nbsp;6&nbsp;-omat&nbsp;func2struct.mat</tt><br>
 <span class="anchor" id="line-555"></span><tt class="backtick">flirt&nbsp;-ref&nbsp;${FSLDIR}/data/standard/MNI152_T1_2mm_brain&nbsp;-in&nbsp;my_betted_structural&nbsp;-omat&nbsp;my_affine_transf.mat</tt><br>
 <span class="anchor" id="line-556"></span><tt class="backtick">fnirt&nbsp;--in=my_structural&nbsp;--aff=my_affine_transf.mat&nbsp;--cout=my_nonlinear_transf&nbsp;--config=T1_2_MNI152_2mm</tt><br>
 <span class="anchor" id="line-557"></span><tt class="backtick">applywarp&nbsp;--ref=${FSLDIR}/data/standard/MNI152_T1_2mm&nbsp;--in=my_functional&nbsp;--warp=my_nonlinear_transf&nbsp;--premat=func2struct.mat&nbsp;--out=my_warped_functional</tt> <span class="anchor" id="line-558"></span><span class="anchor" id="line-559"></span><p class="line874">Registering FA-image to FMRIB58 <span class="anchor" id="line-560"></span><span class="anchor" id="line-561"></span><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;${FSLDIR}/data/standard/FMRIB58_FA_1mm_brain&nbsp;-in&nbsp;my_FA&nbsp;-omat&nbsp;my_affine_transf.mat</tt><br>
 <span class="anchor" id="line-562"></span><tt class="backtick">fnirt&nbsp;--in=my_FA&nbsp;--aff=my_affine_transf.mat&nbsp;--cout=my_nonlinear_transf&nbsp;--config=FA_2_FMRIB58_1mm</tt><br>
 <span class="anchor" id="line-563"></span><tt class="backtick">applywarp&nbsp;--ref=${FSLDIR}/data/standard/FMRIB58_FA_1mm_brain&nbsp;--in=my_FA&nbsp;--warp=my_nonlinear_transf&nbsp;--out=my_warped_FA</tt> <span class="anchor" id="line-564"></span><span class="anchor" id="line-565"></span><p class="line867">
<h1 id="Tools_for_handling_warps">Tools for handling warps</h1>
<span class="anchor" id="line-566"></span><span class="anchor" id="line-567"></span><p class="line867">
<h2 id="Introduction">Introduction</h2>
<span class="anchor" id="line-568"></span><span class="anchor" id="line-569"></span><p class="line862">These are a set of command line utilities for handling, applying and transforming warp-fields created with fnirt, or any other application that produces warp-fields with a compatible format. Using these tools you can take the coefficient-field (the output for the <a href="./FNIRT.html#A--cout">--cout argument of fnirt</a>) and create any other <tt class="backtick">fnirt</tt> output. Hence, it is often a good idea to just specify the <tt class="backtick">--cout</tt> for <tt class="backtick">fnirt</tt>, thereby saving space, and then create the oter files of/when they are needed. <span class="anchor" id="line-570"></span><span class="anchor" id="line-571"></span><p class="line862">The output of the <tt class="backtick">--cout</tt> parameter of <tt class="backtick">fnirt</tt> is a 4D-file with three (for the x-, y- and z-directions) volumes of coefficients for quadratic/cubic splines. To go from a volume of coefficients to a displacement field each of the coefficients are multiplied with a 3D spline with a unique location within the displacement volume. Hence, the field is uniquely defined given the information in the coefficient-file. All (I think) the FSL applications that uses warp-fields have been written so that they accept either a coefficient-file or a field-file, which means that the average user does not really need to know exactly what format his/her warps are in. <span class="anchor" id="line-572"></span><span class="anchor" id="line-573"></span><p class="line867">
<h2 id="fnirtfileutils">fnirtfileutils</h2>
<span class="anchor" id="line-574"></span><span class="anchor" id="line-575"></span><p class="line862">This utility is used to convert field-&gt;coefficients, coefficients-&gt;field, coefficients-&gt;other_coefficients etc. Probably the easiest is to look at some examples. <span class="anchor" id="line-576"></span><span class="anchor" id="line-577"></span><p class="line867"><tt class="backtick">fnirtfileutils&nbsp;--in=my_fnirtcoefs&nbsp;--ref=my_refvol&nbsp;--out=my_field</tt> <span class="anchor" id="line-578"></span><span class="anchor" id="line-579"></span><p class="line874">This command simply converts a coefficient-file into a field-file (with the affine transform NOT included). This can be used e.g. for visualization purposes. <span class="anchor" id="line-580"></span><span class="anchor" id="line-581"></span><p class="line867"><tt class="backtick">fnirtfileutils&nbsp;--in=my_fnirtcoefs&nbsp;--ref=my_refvol&nbsp;--jac=my_jac</tt> <span class="anchor" id="line-582"></span><span class="anchor" id="line-583"></span><p class="line862">This command calculates a map of Jacobian determinants (reflecting expansions/contractions) given a coefficient/field-file. This can be used <em>e.g.</em> for "Jacobian modulation" in <a href="./FSLVBM.html">FSLVBM</a>, or for visualization. If combined with the <tt class="backtick">--withaff</tt> flag the jacobian associated with the affine transform will also be included in the output. <span class="anchor" id="line-584"></span><span class="anchor" id="line-585"></span><p class="line867"><tt class="backtick">fnirtfileutils&nbsp;--in=my_fnirtcoefs&nbsp;--ref=my_refvol&nbsp;--out=my_field&nbsp;--withaff</tt> <span class="anchor" id="line-586"></span><span class="anchor" id="line-587"></span><p class="line874">This command will create a warp-field with the affine transform included as part of the field. This can be useful when one wants to use software that cannot decode the FSL coefficient-file format. <span class="anchor" id="line-588"></span><span class="anchor" id="line-589"></span><p class="line867"><tt class="backtick">fnirtfileutils&nbsp;--in=some_field&nbsp;--ref=some_refvol&nbsp;--out=my_splinecoeffs&nbsp;--outformat=spline&nbsp;--warpres=10</tt> <span class="anchor" id="line-590"></span><span class="anchor" id="line-591"></span><p class="line874">This command will take a displacement-field created e.g. by some non-FSL application and convert it to a fnirt/FSL coefficient file with a spline knot-spacing of 10mm. Note that it may not be possible to represent the field exactly as a combination of splines with a knot-spacing greater than one voxel, so it will be projected onto the closest (in a least-squares sense) field that is possible to represent. <span class="anchor" id="line-592"></span><span class="anchor" id="line-593"></span><p class="line867">
<h3 id="List_of_parameters-1">List of parameters</h3>
<span class="anchor" id="line-594"></span><span class="anchor" id="line-595"></span><p class="line867"><tt class="backtick">--in=filname</tt> <span class="anchor" id="line-596"></span><ul><li style="list-style-type:none">Name of file containing coefficients/field that specifies a set of warps. E.g. the output of the --cout parameter of fnirt. <span class="anchor" id="line-597"></span><span class="anchor" id="line-598"></span></li></ul><p class="line867"><tt class="backtick">--ref=filname</tt> <span class="anchor" id="line-599"></span><ul><li style="list-style-type:none">Name of target file for the warps. This typically the same file that was specified as --ref in fnirt. <span class="anchor" id="line-600"></span><span class="anchor" id="line-601"></span></li></ul><p class="line867"><tt class="backtick">--out=filename</tt> <span class="anchor" id="line-602"></span><ul><li style="list-style-type:none">Name of output file. The format of the output depends on what other parameters are set. The default format is a (4D) field-file. If the --outformat is set to spline the format will be a (4D) file of spline coefficients. <span class="anchor" id="line-603"></span><span class="anchor" id="line-604"></span></li></ul><p class="line867"><tt class="backtick">--outformat=field/spline</tt> <span class="anchor" id="line-605"></span><ul><li style="list-style-type:none">Specifies the output format. If set to field (default) the output will be a (4D) field-file. If set to spline the format will be a (4D) file of spline coefficients. <span class="anchor" id="line-606"></span><span class="anchor" id="line-607"></span></li></ul><p class="line867"><tt class="backtick">--warpres=xres,yres,zres</tt> <span class="anchor" id="line-608"></span><ul><li style="list-style-type:none">Specifes the resolution/knot-spacing of the splines pertaining to the coefficients in the --out file. This parameter is only relevant if --outformat is set to spline. It should be noted that if the --in file has a higher resolution, the resulting coefficents will pertain to the closest (in a least-squares sense) file in the space of fields with the --warpres resolution. It should also be noted that the resolution will always be an integer multiple of the voxel size. <span class="anchor" id="line-609"></span><span class="anchor" id="line-610"></span></li></ul><p class="line867"><tt class="backtick">--knotspace=xksp,yksp,zksp</tt> <span class="anchor" id="line-611"></span><ul><li style="list-style-type:none">Alternative (to --warpres) specifikation of the resolution of the output spline-field. <span class="anchor" id="line-612"></span><span class="anchor" id="line-613"></span></li></ul><p class="line874">--jac=filename <span class="anchor" id="line-614"></span><ul><li style="list-style-type:none">Specifies that a (3D) file of Jacobian determinants corresponding to --in should be produced and written to filename. <span class="anchor" id="line-615"></span><span class="anchor" id="line-616"></span></li></ul><p class="line867"><tt class="backtick">--withaff</tt> <span class="anchor" id="line-617"></span><ul><li style="list-style-type:none">Specifies that the affine transform (i.e. that which was specified for the --aff parameter in fnirt) should be included as displacements in the --out file. That can be useful for interfacing with software that cannot decode FSL/fnirt coefficient-files (where the affine transform is stored separately from the displacements). <span class="anchor" id="line-618"></span><span class="anchor" id="line-619"></span></li></ul><p class="line867"><tt class="backtick">--verbose</tt> <span class="anchor" id="line-620"></span><ul><li style="list-style-type:none">Prompts fnirtfileutils to write additional information to the screen while processing. If you want to report a problem it is a good idea to turn this on and include the output in your report/mail. <span class="anchor" id="line-621"></span><span class="anchor" id="line-622"></span></li></ul><p class="line874">== applywarp -- <span class="anchor" id="line-623"></span><span class="anchor" id="line-624"></span><p class="line867"><tt class="backtick">applywarp</tt> is used to apply the warps estimated by <tt class="backtick">fnirt</tt> (or some other software) to some image. Say e.g. that you have run <tt class="backtick">fnirt</tt> with the command <span class="anchor" id="line-625"></span><span class="anchor" id="line-626"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=my_standard_space&nbsp;--in=my_struct&nbsp;--aff=my_aff&nbsp;--config=my_config_file&nbsp;--cout=my_coefficients</tt> <span class="anchor" id="line-627"></span><span class="anchor" id="line-628"></span><p class="line862">and now you want to apply the warps to <tt class="backtick">my_struct</tt>. You would then use the command <span class="anchor" id="line-629"></span><span class="anchor" id="line-630"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=my_standard_space&nbsp;--in=my_struct&nbsp;--warp=my_coefficients&nbsp;--out=my_warped_struct</tt> <span class="anchor" id="line-631"></span><span class="anchor" id="line-632"></span><p class="line862">Let us now say that the whole point of running <tt class="backtick">fnirt</tt> in the first place was so to warp your functional data into standard space. You will then have previously have run <tt class="backtick">flirt</tt> with a command like <span class="anchor" id="line-633"></span><span class="anchor" id="line-634"></span><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;my_struct&nbsp;-in&nbsp;my_func&nbsp;-omat&nbsp;func2struct.mat&nbsp;-dof&nbsp;6</tt> <span class="anchor" id="line-635"></span><span class="anchor" id="line-636"></span><p class="line874">to align your functional data (my_func) with the structural scan (my_struct) uing a rigid-body transform (dof 6). You can now resample your functional data straight to standard space with a single operation given by <span class="anchor" id="line-637"></span><span class="anchor" id="line-638"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=my_standard_space&nbsp;--in=my_func&nbsp;--out=my_func_in_my_standard_space&nbsp;--warp=my_coefficients&nbsp;--premat=func2struct.mat</tt> <span class="anchor" id="line-639"></span><span class="anchor" id="line-640"></span><p class="line862">Let us further say that maybe you are not altogether happy with <tt class="backtick">my_standard_space</tt>. It could <em>e.g</em>. be the MNI-space, which as we know is not identical to Talairach. Let us further say that you have (don't ask me how) an affine transform (<tt class="backtick">MNI_2_Tal.mat</tt>) that maps the MNI space to something that is a better approximation of the Talairach space. You can then transform your data straight into "your Talairach space" with the command <span class="anchor" id="line-641"></span><span class="anchor" id="line-642"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=my_Tal_space&nbsp;--in=my_func&nbsp;--out=my_func_in_Tal_Space&nbsp;--warp=my_coefficients&nbsp;--premat=func2struct.mat&nbsp;--postmat=MNI_2_Tal.mat</tt> <span class="anchor" id="line-643"></span><span class="anchor" id="line-644"></span><p class="line862">The final point to mention is interpolation. The default interpolation method is tri-linear, which is mostly sufficient and what we want to do. There are times though when it is better to use "nearest neighbour" interpolation, which means "set the intensity in the output voxel to the same value as the closest (after the mapping) voxel in the input volume". An advantage of nearest-neighbour interpolation is that it does't create any "new" intensity values. Let us say <em>e.g</em>. that we have a file of ROI's, where each ROI is characterized by a given intensity value. If we e.g. have three ROI's the voxels in the ROI-volume would take the values 0, 1, 2 or 3. Let us say that these ROI's have been defined in MNI-space, and that we now want to map them into a subjects native space. If we were then to use the command <span class="anchor" id="line-645"></span><span class="anchor" id="line-646"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=my_native_space&nbsp;--in=ROIs_in_MNI_space&nbsp;--warp=native_2_MNI_coefficients&nbsp;--out=ROIs_in_native_space</tt> <span class="anchor" id="line-647"></span><span class="anchor" id="line-648"></span><p class="line874">the output would contain interpolated non-integer values along the edges of the ROI's. If one instead uses <span class="anchor" id="line-649"></span><span class="anchor" id="line-650"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=my_native_space&nbsp;--in=ROIs_in_MNI_space&nbsp;--warp=native_2_MNI_coefficients&nbsp;--out=ROIs_in_native_space&nbsp;--interp=nn</tt> <span class="anchor" id="line-651"></span><span class="anchor" id="line-652"></span><p class="line874">the output will contain only the original values 0, 1, 2 or 3 and all the ROI's would contain only relevant values. <span class="anchor" id="line-653"></span><span class="anchor" id="line-654"></span><p class="line867">
<h3 id="List_of_parameters-2">List of parameters</h3>
<span class="anchor" id="line-655"></span><span class="anchor" id="line-656"></span><p class="line867"><tt class="backtick">--in=filname</tt> <span class="anchor" id="line-657"></span><ul><li style="list-style-type:none">Name of file to which the warps should be applied. <span class="anchor" id="line-658"></span><span class="anchor" id="line-659"></span></li></ul><p class="line867"><tt class="backtick">--ref=filname</tt> <span class="anchor" id="line-660"></span><ul><li style="list-style-type:none">Name of a file in target space. This typically the same file that was specified as --ref in fnirt. <span class="anchor" id="line-661"></span><span class="anchor" id="line-662"></span></li></ul><p class="line867"><tt class="backtick">--warp=filname</tt> <span class="anchor" id="line-663"></span><ul><li style="list-style-type:none"><p class="line862">Name of a file with warp coefficients/fields. This typically the output given by the <tt class="backtick">--cout</tt> parameter of fnirt. <span class="anchor" id="line-664"></span><span class="anchor" id="line-665"></span></li></ul><p class="line867"><tt class="backtick">--out=filename</tt> <span class="anchor" id="line-666"></span><ul><li style="list-style-type:none"><p class="line862">Name of output file, i.e. the <tt class="backtick">--in</tt> file warped into the space of the <tt class="backtick">--ref</tt> file. <span class="anchor" id="line-667"></span><span class="anchor" id="line-668"></span></li></ul><p class="line867"><tt class="backtick">--abs</tt> <span class="anchor" id="line-669"></span><ul><li style="list-style-type:none">If set it indicates that the warps in --warp should be interpreted as absolute. I.e. the values in --warp are the coordinates in the --ref space, rather than displacements. This flag is ignored if --warp was created by fnirt, which always creates relative displacements. <span class="anchor" id="line-670"></span><span class="anchor" id="line-671"></span></li></ul><p class="line867"><tt class="backtick">--rel</tt> <span class="anchor" id="line-672"></span><ul><li style="list-style-type:none"><p class="line862">If set it indicates that the warps in <tt class="backtick">--warp</tt> should be interpreted as relative. I.e. the values in <tt class="backtick">--warp</tt> are displacements from the coordinates in the <tt class="backtick">--ref</tt> space. <span class="anchor" id="line-673"></span><span class="anchor" id="line-674"></span></li></ul><p class="line867"><tt class="backtick">--datatype=char/short/int/float/double</tt> <span class="anchor" id="line-675"></span><ul><li style="list-style-type:none"><p class="line862">Forces the data type in <tt class="backtick">--out</tt> to be that given by the argument. If it is not set the data type in <tt class="backtick">--out</tt> will be the same as in <tt class="backtick">--in</tt>. <span class="anchor" id="line-676"></span><span class="anchor" id="line-677"></span></li></ul><p class="line867"><tt class="backtick">--super</tt> <span class="anchor" id="line-678"></span><ul><li style="list-style-type:none"><p class="line862">Indicates that an intermediary sampling level should be used. This is relevant primarily when using nearest-neighbour interpolation from an <tt class="backtick">--in</tt> with higher resolution than given by <tt class="backtick">--ref</tt>. It is e.g. used in TBSS when projecting the skeleton from the (high resolution) template back to native space. If it was not used the back-projected skeleton may no longer be continous. <span class="anchor" id="line-679"></span><span class="anchor" id="line-680"></span></li></ul><p class="line867"><tt class="backtick">--superlevel=#&nbsp;or&nbsp;--superlevel=a</tt> <span class="anchor" id="line-681"></span><ul><li style="list-style-type:none"><p class="line862">Specifies the level of super-sampling (relative the <tt class="backtick">--ref</tt> volume) for the intermediary sampling step. If set to superlevel=a the supersampling will be adjusted so that the intermediary step has at least the resolution of the <tt class="backtick">--in</tt> file in all directions. It will be ignored if <tt class="backtick">--super</tt> isn't set. <span class="anchor" id="line-682"></span><span class="anchor" id="line-683"></span></li></ul><p class="line867"><tt class="backtick">--premat=filename</tt> <span class="anchor" id="line-684"></span>Specifies an affine transform that should be applied to the data prior to the non-linear warping. <span class="anchor" id="line-685"></span><span class="anchor" id="line-686"></span><p class="line867"><tt class="backtick">--postmat=filename</tt> <span class="anchor" id="line-687"></span>Specifies an affine transform that should be applied to the data following to the non-linear warping. <span class="anchor" id="line-688"></span><span class="anchor" id="line-689"></span><p class="line867"><tt class="backtick">--mask=filename</tt> <span class="anchor" id="line-690"></span>Specifies a volume (in the space of <tt class="backtick">--ref</tt>) that should be multiplied with the <tt class="backtick">--out</tt> file. <span class="anchor" id="line-691"></span><span class="anchor" id="line-692"></span><p class="line867"><tt class="backtick">--interp=nn/trilinear/sinc</tt> <span class="anchor" id="line-693"></span>Specifies which interpolation model to use when resampling <tt class="backtick">--in</tt>. The default is <tt class="backtick">trilinear</tt>, which is mostly sufficient. <span class="anchor" id="line-694"></span><span class="anchor" id="line-695"></span><p class="line867"><tt class="backtick">--verbose</tt> <span class="anchor" id="line-696"></span>Prompts <tt class="backtick">applywarp</tt> to write additional information to the screen while processing. If you want to report a problem it is a good idea to turn this on and include the output in your report/mail. <span class="anchor" id="line-697"></span><span class="anchor" id="line-698"></span><p class="line867">
<h2 id="invwarp">invwarp</h2>
<span class="anchor" id="line-699"></span><span class="anchor" id="line-700"></span><p class="line867"><tt class="backtick">invwarp</tt> is used to "reverse" a non-linear mapping, much in the same way as one would use <span class="anchor" id="line-701"></span><span class="anchor" id="line-702"></span><p class="line867"><tt class="backtick">convert_xfm&nbsp;-omat&nbsp;B2A.mat&nbsp;-inverse&nbsp;A2B.mat</tt> <span class="anchor" id="line-703"></span><span class="anchor" id="line-704"></span><p class="line874">to "reverse" a linear mapping. It can e.g. be useful if one wants to use a set of ROI's that have been specified once and for all in standard space by projecting them into the space of individual subjects. Let us e.g. say that we have run fnirt with <span class="anchor" id="line-705"></span><span class="anchor" id="line-706"></span><p class="line867"><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm&nbsp;--in=my_struct&nbsp;--aff=my_aff&nbsp;--cout=warps_into_MNI_space&nbsp;--config=T1_2_MNI152_2mm</tt> <span class="anchor" id="line-707"></span><span class="anchor" id="line-708"></span><p class="line862">and that we have a ROI in MNI-space, in the binary file <tt class="backtick">ACC_left.nii.gz</tt>, that we would like to apply to my_struct in its native space. We can then use invwarp to reverse the my_struct-&gt;MNI mapping with the command <span class="anchor" id="line-709"></span><span class="anchor" id="line-710"></span><p class="line874">invwarp --ref=my_struct --warp=warps_into_MNI_space --out=warps_into_my_struct_space <span class="anchor" id="line-711"></span>and we can then use that mapping to warp the ROI into the subjects native space with <span class="anchor" id="line-712"></span><span class="anchor" id="line-713"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=my_struct&nbsp;--in=ACC_left&nbsp;--warp=warps_into_my_struct_space&nbsp;--out=ACC_left_in_my_struct_space&nbsp;--interp=nn</tt> <span class="anchor" id="line-714"></span>It should be noted that invwarp is quite computationally intensive, and may take quite long to run. To reduce execution time it may e.g. be a good idea to crop <tt class="backtick">my_struct</tt> (before any of the processing steps) so that the FOV is reasonably "tight". If you look at the MNI templates you can get an idea of what a suitable "tightness" is. <span class="anchor" id="line-715"></span><span class="anchor" id="line-716"></span><p class="line867">
<h3 id="List_of_parameters-3">List of parameters</h3>
<span class="anchor" id="line-717"></span><span class="anchor" id="line-718"></span><p class="line867"><tt class="backtick">--warp=filname</tt> <span class="anchor" id="line-719"></span><ul><li style="list-style-type:none">Name of file containing warp-coefficients/fields. This would typically be the output from the --cout switch of fnirt (but can also use fields, like the output from --fout). <span class="anchor" id="line-720"></span><span class="anchor" id="line-721"></span></li></ul><p class="line867"><tt class="backtick">--ref=filname</tt> <span class="anchor" id="line-722"></span><ul><li style="list-style-type:none">Name of a file in target space. Note that the target space is now different from the target space that was used to create the --warp file. It would typically be the file that was specified with the --in argument when running fnirt. <span class="anchor" id="line-723"></span><span class="anchor" id="line-724"></span></li></ul><p class="line867"><tt class="backtick">--out=filename</tt> <span class="anchor" id="line-725"></span><ul><li style="list-style-type:none">Name of output file, containing warps that are the "reverse" of those in --warp. This will be a field-file (rather than a file of spline coefficients), and it will have any affine component included as part of the displacements. <span class="anchor" id="line-726"></span><span class="anchor" id="line-727"></span></li></ul><p class="line867"><tt class="backtick">--abs</tt> <span class="anchor" id="line-728"></span><ul><li style="list-style-type:none">If set it indicates that the warps in --warp should be interpreted as absolute, provided that it is not created by fnirt (which always uses relative warps). If set it also indicates that the output --out should be absolute. <span class="anchor" id="line-729"></span><span class="anchor" id="line-730"></span></li></ul><p class="line867"><tt class="backtick">--rel</tt> <span class="anchor" id="line-731"></span><ul><li style="list-style-type:none">If set it indicates that the warps in --warp should be interpreted as relative. I.e. the values in --warp are displacements from the coordinates in the --ref space. If set it also indicates that the output --out should be relative. <span class="anchor" id="line-732"></span><span class="anchor" id="line-733"></span></li></ul><p class="line867"><tt class="backtick">--niter=#</tt> <span class="anchor" id="line-734"></span><ul><li style="list-style-type:none">Determines how many iterations of the gradient-descent search that should be run. <span class="anchor" id="line-735"></span><span class="anchor" id="line-736"></span></li></ul><p class="line867"><tt class="backtick">--regularise</tt> <span class="anchor" id="line-737"></span><ul><li style="list-style-type:none">Regularisation strength (deafult=1.0). <span class="anchor" id="line-738"></span><span class="anchor" id="line-739"></span></li></ul><p class="line867"><tt class="backtick">--noconstraint</tt> <span class="anchor" id="line-740"></span><ul><li style="list-style-type:none">Do not apply Jacobian constraint <span class="anchor" id="line-741"></span><span class="anchor" id="line-742"></span></li></ul><p class="line867"><tt class="backtick">--jmin=val</tt> <span class="anchor" id="line-743"></span><ul><li style="list-style-type:none">Minimum acceptable Jacobian value for constraint (default 0.01) <span class="anchor" id="line-744"></span><span class="anchor" id="line-745"></span></li></ul><p class="line867"><tt class="backtick">--jmax=val</tt> <span class="anchor" id="line-746"></span><ul><li style="list-style-type:none">Maximum acceptable Jacobian value for constraint (default 100.0) <span class="anchor" id="line-747"></span><span class="anchor" id="line-748"></span></li></ul><p class="line867"><tt class="backtick">--verbose</tt> <span class="anchor" id="line-749"></span><ul><li style="list-style-type:none">Prompts invwarp to write additional information to the screen while processing. If you want to report a problem it is a good idea to turn this on and include the output in your report/mail. <span class="anchor" id="line-750"></span><span class="anchor" id="line-751"></span></li></ul><p class="line867">
<h2 id="convertwarp">convertwarp</h2>
<span class="anchor" id="line-752"></span><span class="anchor" id="line-753"></span><p class="line874">convertwarp is a general tool for combining multiple transforms into one. In its most general form it allows one to specify a transform of the form <span class="anchor" id="line-754"></span><span class="anchor" id="line-755"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/convertwarp.png" title="basis functions" /> <span class="anchor" id="line-756"></span><span class="anchor" id="line-757"></span><span class="anchor" id="line-758"></span><p class="line862">where <strong>d</strong><sup>(CD)</sup> and <strong>d</strong><sup>(BC)</sup> corresponds to the arguments to <tt class="backtick">--warp1</tt> and <tt class="backtick">--warp2</tt> respectively and where s corresponds to --shiftmap (which has been applied in the y-direction in this example). <strong>M</strong><sup>(DE)</sup> and <strong>M</strong><sup>(AB)</sup> correspond to the inverses of the arguments to <tt class="backtick">--premat</tt> and <tt class="backtick">--postmat</tt> respectively. In the equation above <strong>x</strong><sub>F</sub> corresponds to the output provided the <tt class="backtick">--absout</tt> flag has been set. If not, or if the <tt class="backtick">--relout</tt> flag has been set, the original coordinates ([x<sub>A</sub> y<sub>A</sub> z<sub>A</sub>]<sup>T</sup> above) has been subtracted away. <span class="anchor" id="line-759"></span><span class="anchor" id="line-760"></span><p class="line862">It is probably not for the faint of heart, but for others it might be useful. Say <em>e.g.</em> that we have some functional data <tt class="backtick">func.nii.gz</tt> for which we have a fieldmap that has been pre-processed into a "shiftmap" (see fugue manual) that we have called <tt class="backtick">shiftmap.nii.gz</tt>. Let us also assume that we have a structural scan called <tt class="backtick">struct.nii.gz</tt> and that we have run <span class="anchor" id="line-761"></span><span class="anchor" id="line-762"></span><p class="line867"><tt class="backtick">flirt&nbsp;-ref&nbsp;struct&nbsp;-in&nbsp;func&nbsp;-omat&nbsp;func2struct.mat</tt><br>
 <span class="anchor" id="line-763"></span><tt class="backtick">fnirt&nbsp;--ref=MNI152_T1_2mm&nbsp;--in=struct&nbsp;--aff=Aff_MNI2struct&nbsp;--config=T1_2_MNI152_2mm&nbsp;--cout=Nonlin_MNI2struct</tt> <span class="anchor" id="line-764"></span><span class="anchor" id="line-765"></span><p class="line874">We can then create a single transform that maps the functional scan into the MNI-space with the command <span class="anchor" id="line-766"></span><span class="anchor" id="line-767"></span><p class="line867"><tt class="backtick">convertwarp&nbsp;--ref=MNI152_T1_2mm&nbsp;--warp1=Nonlin_MNI2struct&nbsp;--shiftmap=shiftmap&nbsp;--shiftdir=y&nbsp;--premat=func2struct.mat&nbsp;--out=my_comprehensive_warps&nbsp;--relout</tt> <span class="anchor" id="line-768"></span><span class="anchor" id="line-769"></span><p class="line874">which we can then use to transform func.nii.gz into the MNI-space with the command <span class="anchor" id="line-770"></span><span class="anchor" id="line-771"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=MNI152_T1_2mm&nbsp;--in=func&nbsp;--warp=my_comprehensive_warps&nbsp;--rel&nbsp;--out=func_in_MNI_space</tt> <span class="anchor" id="line-772"></span><span class="anchor" id="line-773"></span><p class="line867">
<h3 id="List_of_parameters-4">List of parameters</h3>
<span class="anchor" id="line-774"></span><span class="anchor" id="line-775"></span><p class="line867"><tt class="backtick">--ref=filname</tt> <span class="anchor" id="line-776"></span><ul><li style="list-style-type:none">Name of a file in target space of the full transform. <span class="anchor" id="line-777"></span><span class="anchor" id="line-778"></span></li></ul><p class="line867"><tt class="backtick">--out=filename</tt> <span class="anchor" id="line-779"></span><ul><li style="list-style-type:none">Name of output file, containing warps that are the combination of all those given as arguments. The format of this will be a field-file (rather than spline coefficients) with any affine components included. <span class="anchor" id="line-780"></span><span class="anchor" id="line-781"></span></li></ul><p class="line867"><tt class="backtick">--premat=filename</tt> <span class="anchor" id="line-782"></span><ul><li style="list-style-type:none">Name of file containing affine transform corresponding e.g. to a rigid-body transform of a subjects functional scan to his/her structural. <span class="anchor" id="line-783"></span><span class="anchor" id="line-784"></span></li></ul><p class="line867"><tt class="backtick">--warp1=filename</tt> <span class="anchor" id="line-785"></span><ul><li style="list-style-type:none">Name of file containing warp-fields/coefficients. This could e.g. be a fnirt-transform from a subjects structural scan to an average of a group of subjects. <span class="anchor" id="line-786"></span><span class="anchor" id="line-787"></span></li></ul><p class="line867"><tt class="backtick">--warp2=filename</tt> <span class="anchor" id="line-788"></span><ul><li style="list-style-type:none">Name of file containing warp-fields/coefficients. This could e.g. be a fnirt-transform from the average of a group of subjects to some standard space (e.g. MNI152). <span class="anchor" id="line-789"></span><span class="anchor" id="line-790"></span></li></ul><p class="line867"><tt class="backtick">--postmat=filename</tt> <span class="anchor" id="line-791"></span><ul><li style="list-style-type:none">Name of file containing an affine transform. It could e.g. be an affine transform that maps the MNI152-space into a better approximation to the Talairach-space (if indeed there is one). <span class="anchor" id="line-792"></span><span class="anchor" id="line-793"></span></li></ul><p class="line867"><tt class="backtick">--shiftmap=filename</tt> <span class="anchor" id="line-794"></span><ul><li style="list-style-type:none"><p class="line862">Name of file containing a "shiftmap", a non-linear transform with displacements only in one direction. This would typically be a fieldmap that has been pre-processed using <a href="./FUGUE.html">fugue</a> that maps a subjects functional (EPI) data onto an undistorted space (<em>i.e.</em> a space that corresponds to his/her true anatomy). <span class="anchor" id="line-795"></span><span class="anchor" id="line-796"></span></li></ul><p class="line867"><tt class="backtick">--shiftdir=x/y/z/-x/-y/-z</tt> <span class="anchor" id="line-797"></span><ul><li style="list-style-type:none"><p class="line862">Indicates the direction that the distortions from <tt class="backtick">--shiftmap</tt> goes. It depends on the direction and polarity of the phase-encoding in the EPI sequence. <span class="anchor" id="line-798"></span><span class="anchor" id="line-799"></span></li></ul><p class="line867"><tt class="backtick">--jstats</tt> <span class="anchor" id="line-800"></span>Print out statistics of the Jacobian of the warpfield. <span class="anchor" id="line-801"></span><span class="anchor" id="line-802"></span><p class="line867"><tt class="backtick">--constrainj</tt> <span class="anchor" id="line-803"></span><ul><li style="list-style-type:none">Constrain the Jacobian of the warpfield to lie within specified min/max limits. <span class="anchor" id="line-804"></span><span class="anchor" id="line-805"></span></li></ul><p class="line867"><tt class="backtick">--jmin=value</tt> <span class="anchor" id="line-806"></span><ul><li style="list-style-type:none">Minimum acceptable Jacobian value for constraint (default 0.01). <span class="anchor" id="line-807"></span><span class="anchor" id="line-808"></span></li></ul><p class="line867"><tt class="backtick">--jmax=value</tt> <span class="anchor" id="line-809"></span><ul><li style="list-style-type:none">Maximum acceptable Jacobian value for constraint (default 100.0). <span class="anchor" id="line-810"></span><span class="anchor" id="line-811"></span></li></ul><p class="line867"><tt class="backtick">--abs</tt> <span class="anchor" id="line-812"></span><ul><li style="list-style-type:none"><p class="line862">If set it indicates that the warps in <tt class="backtick">--warp1</tt> and <tt class="backtick">--warp2</tt> should be interpreted as absolute. I.e. the values in --warp1/2 are the coordinates in the next space, rather than displacements. This flag is ignored if <tt class="backtick">--warp1/2</tt> was created by fnirt, which always creates relative displacements. <span class="anchor" id="line-813"></span><span class="anchor" id="line-814"></span></li></ul><p class="line867"><tt class="backtick">--rel</tt> <span class="anchor" id="line-815"></span>If set it indicates that the warps in <tt class="backtick">--warp1/2</tt> should be interpreted as relative. I.e. the values in <tt class="backtick">--warp1/2</tt> are displacements from the coordinates in the next space. <span class="anchor" id="line-816"></span><span class="anchor" id="line-817"></span><p class="line867"><tt class="backtick">--absout</tt> <span class="anchor" id="line-818"></span>If set it indicates that the warps in <tt class="backtick">--out</tt> should be absolute, i.e. the vaulues in <tt class="backtick">--out</tt> are the coordinates in <tt class="backtick">--ref</tt>, rather than displacements. <span class="anchor" id="line-819"></span><span class="anchor" id="line-820"></span><p class="line867"><tt class="backtick">--relout</tt> <span class="anchor" id="line-821"></span>If set it indicates that the warps in <tt class="backtick">--out</tt> should be relative, i.e. the vaulues in <tt class="backtick">--out</tt> are displacements from the coordinates in <tt class="backtick">--ref</tt>. <span class="anchor" id="line-822"></span><span class="anchor" id="line-823"></span><p class="line867"><tt class="backtick">--verbose</tt> <span class="anchor" id="line-824"></span>Prompts convertwarp to write additional information to the screen while processing. If you want to report a problem it is a good idea to turn this on and include the output in your report/mail. <span class="anchor" id="line-825"></span><span class="anchor" id="line-826"></span><p class="line867">
<h1 id="Some_examples_of_composite_warps">Some examples of composite warps</h1>
<span class="anchor" id="line-827"></span><span class="anchor" id="line-828"></span><p class="line867">
<h2 id="Introduction-1">Introduction</h2>
<span class="anchor" id="line-829"></span><span class="anchor" id="line-830"></span><p class="line874">Here we show how to perform some common tasks that involve going back and forth between different spaces when the mapping from one space to the other consists of more than a single transform. <span class="anchor" id="line-831"></span><span class="anchor" id="line-832"></span><p class="line867">
<h2 id="Transforming_a_functional_image_into_standard_space">Transforming a functional image into standard space</h2>
<span class="anchor" id="line-833"></span><span class="anchor" id="line-834"></span><p class="line862">Let us say we have an image in "functional space" that we call <tt class="backtick">example_func</tt> and an image in "structural space" that we call highres. For a given subject these images are simply a functional image (<tt class="backtick">example_func</tt>) and a structural image (<tt class="backtick">highres</tt>) aquired on that particular subject. The naming reflects the names given to them in a standard analysis with feat. <span class="anchor" id="line-835"></span><span class="anchor" id="line-836"></span><p class="line862">Let us further say that there is a file named <tt class="backtick">example_func2highres.mat</tt> with a rigid-body transformation mapping <tt class="backtick">example_func</tt> onto <tt class="backtick">highres</tt>. This file will have been produced by a call to <tt class="backtick">flirt</tt>, possibly from within <tt class="backtick">feat</tt>. Let us also assume that there is a non-linear mapping of highres onto standard space called <tt class="backtick">highres2standard_warp.nii.gz</tt>. <span class="anchor" id="line-837"></span><span class="anchor" id="line-838"></span><p class="line874">We can now transform example_func straight to standard space with the command <span class="anchor" id="line-839"></span><span class="anchor" id="line-840"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=standard&nbsp;--in=example_func&nbsp;--warp=highres2standard_warp&nbsp;--premat=example_func2highres.mat&nbsp;--out=example_func_in_standard_space</tt> <span class="anchor" id="line-841"></span>which will combine the transforms in <tt class="backtick">highres2standard_warp</tt> and <tt class="backtick">example_func2highres.mat</tt> into a single transform that is applied to example_func. Note that in the example above we specified standard as our reference image in standard space. This will work when in a feat directory where standard will point to the image that was used as <tt class="backtick">--ref</tt> when running <tt class="backtick">fnirt</tt>. If you are somehere else you will need to explicitly specify that image (e.g. <tt class="backtick">--ref=$FSLDIR/data/standard/MNI152_T1_2mm</tt>). <span class="anchor" id="line-842"></span><span class="anchor" id="line-843"></span><p class="line867">
<h2 id="Transforming_an_image_.28.27.27e.g..27.27_a_mask.29_in_standard_space_into_functional_space">Transforming an image (''e.g.'' a mask) in standard space into functional space</h2>
<span class="anchor" id="line-844"></span><span class="anchor" id="line-845"></span><p class="line862">Let us say we have a region of interest (ROI) for the putamen that has been defined in standard space, and let us also assume that we want to extract a time-series from the putamen in a number of different subjects. We would then want to transform the putamen ROI into the functional space of each of those subjects. The required transform is then the opposite (inverse) of the case above, <em>i.e</em>. we want the standard-&gt;functional transform. This will also be a composite transform, one that is a combination of the inverses of the individual transforms. If you are running feat there will already be an inverse of <tt class="backtick">example_func2struct</tt> calculated for you with the name <tt class="backtick">highres2example_func.mat</tt>. If not, it can easily be created using the command <span class="anchor" id="line-846"></span><span class="anchor" id="line-847"></span><p class="line867"><tt class="backtick">convert_xfm&nbsp;-omat&nbsp;highres2example_func.mat&nbsp;-inverse&nbsp;example_func2highres.mat</tt> <span class="anchor" id="line-848"></span><span class="anchor" id="line-849"></span><p class="line862">We also need the inverse of the non-linear transform <tt class="backtick">highres2standard_warp</tt>. If you have run <tt class="backtick">featquery</tt> it will already exist and be called <tt class="backtick">highres2standard_warp_inv</tt>. If not it can be generated with the command <span class="anchor" id="line-850"></span><span class="anchor" id="line-851"></span><p class="line867"><tt class="backtick">invwarp&nbsp;--ref==highres&nbsp;--warp=highres2standard_warp&nbsp;--out=highres2standard_warp_inv</tt> <span class="anchor" id="line-852"></span><span class="anchor" id="line-853"></span><p class="line862">These two (<tt class="backtick">highres2example_func.mat</tt> and <tt class="backtick">highres2standard_warp_inv</tt>) can now be used to bring the mask into standard space with the command <span class="anchor" id="line-854"></span><span class="anchor" id="line-855"></span><p class="line867"><tt class="backtick">applywarp&nbsp;--ref=example_func&nbsp;--in=mask_in_standard_space&nbsp;--warp=highres2standard_warp_inv&nbsp;--postmat=highres2example_func.mat&nbsp;--out=mask_in_functional_space</tt> <span class="anchor" id="line-856"></span><span class="anchor" id="line-857"></span><p class="line862">N.B. that we have now used the <tt class="backtick">--postmat</tt> argument (rather than the <tt class="backtick">--premat</tt> argument as we did for the forward transform). This is "equivalent" to <span class="anchor" id="line-858"></span><span class="anchor" id="line-859"></span><p class="line867"><img align="top" alt="basis functions" class="attachment" src="attachments/FNIRT(2f)UserGuide/combined_inverse.png" title="basis functions" /> <span class="anchor" id="line-860"></span><span class="anchor" id="line-861"></span><p class="line862">where <strong>A</strong> and <strong>B</strong> are matrices (linear transforms). Note also that <tt class="backtick">applywarp</tt> uses linear interpolation as default which means that the image <tt class="backtick">mask_in_functional_space</tt> will have values between 0 and 1 (assuming <tt class="backtick">mask_in_standard_space</tt> was binary). Direct use of <tt class="backtick">mask_in_funcional_space</tt> will yield a weighted average, which may or may not be approppriate. It (<tt class="backtick">mask_in_functional_space</tt>) can be converted to a binary mask using <em>e.g</em>. <span class="anchor" id="line-862"></span><span class="anchor" id="line-863"></span><p class="line867"><tt class="backtick">fslmaths&nbsp;mask_in_functional_space&nbsp;-thr&nbsp;0.5&nbsp;-bin&nbsp;mask_in_functional_space</tt> <span class="anchor" id="line-864"></span><hr /><p class="line874"> <span class="anchor" id="line-865"></span><a href="./CategoryFNIRT.html">CategoryFNIRT</a> <span class="anchor" id="line-866"></span><span class="anchor" id="bottom"></span></div>
</div>
<hr>
2014-07-08 15:33
</body>
</html>
